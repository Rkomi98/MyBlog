<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Why Rust Seems Difficult at First (and Why It&#39;s Actually Not) | Mirko Calcaterra</title>
  <meta name="description" content="Why Rust Seems Difficult at First (and Why It&#39;s Actually Not) Introduction Rust is often celebrated as one of the &quot;most loved&quot; languages by developers, and for good reasons: it guarantees high performance, memory safety, and a modern ecosystem. Yet, those who‚Ä¶">
  <meta name="author" content="Mirko Calcaterra">
  <link rel="canonical" href="https://rkomi98.github.io/MyBlog/blog/en/perche-rust/">

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-9EVQ8G9W48"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-9EVQ8G9W48');
  </script>

  <!-- Open Graph -->
  <meta property="og:type" content="article">
  <meta property="og:url" content="https://rkomi98.github.io/MyBlog/blog/en/perche-rust/">
  <meta property="og:title" content="Why Rust Seems Difficult at First (and Why It&#39;s Actually Not)">
  <meta property="og:description" content="Why Rust Seems Difficult at First (and Why It&#39;s Actually Not) Introduction Rust is often celebrated as one of the &quot;most loved&quot; languages by developers, and for good reasons: it guarantees high performance, memory safety, and a modern ecosystem. Yet, those who‚Ä¶">
  <meta property="og:image" content="https://rkomi98.github.io/MyBlog/Assets/Logo.png">
  <meta property="article:published_time" content="2025-12-23T00:00:00.000Z">
  <meta property="article:author" content="Mirko Calcaterra">
  <meta property="article:section" content="Rust">

  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:title" content="Why Rust Seems Difficult at First (and Why It&#39;s Actually Not)">
  <meta property="twitter:description" content="Why Rust Seems Difficult at First (and Why It&#39;s Actually Not) Introduction Rust is often celebrated as one of the &quot;most loved&quot; languages by developers, and for good reasons: it guarantees high performance, memory safety, and a modern ecosystem. Yet, those who‚Ä¶">
  <meta property="twitter:image" content="https://rkomi98.github.io/MyBlog/Assets/Logo.png">

  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "headline": "Why Rust Seems Difficult at First (and Why It&#39;s Actually Not)",
    "image": "https://rkomi98.github.io/MyBlog/Assets/Logo.png",
    "datePublished": "2025-12-23T00:00:00.000Z",
    "dateModified": "2025-12-23T15:05:11.350Z",
    "author": {
      "@type": "Person",
      "name": "Mirko Calcaterra",
      "url": "https://rkomi98.github.io/MyBlog/"
    },
    "publisher": {
      "@type": "Person",
      "name": "Mirko Calcaterra"
    },
    "description": "Why Rust Seems Difficult at First (and Why It&#39;s Actually Not) Introduction Rust is often celebrated as one of the &quot;most loved&quot; languages by developers, and for good reasons: it guarantees high performance, memory safety, and a modern ecosystem. Yet, those who‚Ä¶"
  }
  </script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      box-sizing: border-box;
    }
    html {
      scroll-behavior: smooth;
    }
    body {
      margin: 0;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: radial-gradient(120% 120% at 50% 0%, rgba(59, 130, 246, 0.18) 0%, transparent 65%), var(--bg-primary);
      color: var(--text-primary);
      transition: background 0.3s ease, color 0.3s ease;
      --bg-primary: #0f172a;
      --bg-secondary: #111c33;
      --bg-card: rgba(15, 23, 42, 0.78);
      --bg-card-strong: rgba(15, 23, 42, 0.9);
      --border: rgba(148, 163, 184, 0.24);
      --text-primary: #e2e8f0;
      --text-secondary: #cbd5f5;
      --text-muted: #94a3b8;
      --accent: #60a5fa;
      --accent-strong: #38bdf8;
      --shadow-lg: 0 28px 60px -36px rgba(15, 23, 42, 0.9);
      --code-inline-bg: rgba(6, 11, 19, 0.92);
      --code-block-bg: #050912;
      --code-border: rgba(148, 163, 184, 0.35);
      --code-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.12);
      --code-text: #f8fafc;
    }
    body[data-theme="light"] {
      --bg-primary: #f8fafc;
      --bg-secondary: #ffffff;
      --bg-card: rgba(255, 255, 255, 0.96);
      --bg-card-strong: rgba(248, 250, 252, 0.98);
      --border: rgba(148, 163, 184, 0.18);
      --text-primary: #0f172a;
      --text-secondary: #334155;
      --text-muted: #64748b;
      --accent: #2563eb;
      --accent-strong: #1d4ed8;
      --shadow-lg: 0 28px 50px -38px rgba(15, 23, 42, 0.18);
      background: radial-gradient(120% 120% at 50% 0%, rgba(59, 130, 246, 0.12) 0%, transparent 60%), var(--bg-primary);
    }
    body[data-theme="light"] .post-toc {
      background: rgba(255, 255, 255, 0.96);
    }
    body[data-theme="light"] .post-body {
      background: rgba(255, 255, 255, 0.96);
      color: var(--text-secondary);
    }
    body[data-theme="light"] .post-hero__category {
      background: rgba(37, 99, 235, 0.12);
      color: var(--accent-strong);
    }
    body[data-theme="light"] .post-body blockquote {
      background: rgba(37, 99, 235, 0.1);
      color: var(--text-primary);
    }
    a {
      color: inherit;
      text-decoration: none;
    }
    header.site-header {
      position: sticky;
      top: 0;
      z-index: 12;
      backdrop-filter: blur(14px);
      background: rgba(15, 23, 42, 0.85);
      border-bottom: 1px solid var(--border);
      transition: background 0.3s ease;
    }
    body[data-theme="light"] header.site-header {
      background: rgba(248, 250, 252, 0.9);
    }
    .site-header__inner {
      max-width: 960px;
      margin: 0 auto;
      padding: 1.15rem 2rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1.5rem;
    }
    .site-header__left {
      display: flex;
      align-items: center;
      gap: 1.75rem;
    }
    .logo {
      display: inline-flex;
      align-items: center;
      gap: 0.7rem;
      font-weight: 600;
      color: var(--text-primary);
      font-size: 1.05rem;
      letter-spacing: 0.01em;
    }
    .logo-img {
      width: 38px;
      height: 38px;
      border-radius: 12px;
      object-fit: cover;
      box-shadow: 0 8px 18px -12px rgba(15, 23, 42, 0.6);
    }
    .site-nav {
      display: flex;
      gap: 1.1rem;
      font-size: 0.95rem;
      font-weight: 500;
      color: var(--text-muted);
    }
    .site-nav a:hover {
      color: var(--accent);
    }
    .header-controls {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    .lang-btn {
      border: 1px solid var(--border);
      background: var(--bg-card);
      color: var(--text-primary);
      padding: 0.45rem 0.9rem;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border 0.2s ease, transform 0.2s ease;
    }
    .lang-btn:hover:not(.lang-btn--disabled) {
      background: var(--accent);
      color: #ffffff;
      transform: translateY(-1px);
      border-color: transparent;
    }
    .lang-btn--disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .theme-toggle {
      position: relative;
      width: 52px;
      height: 28px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--bg-card);
      cursor: pointer;
      padding: 0;
      transition: background 0.3s ease, border 0.3s ease;
      display: flex;
      align-items: center;
    }
    .theme-toggle .theme-thumb {
      position: absolute;
      top: 50%;
      left: 4px;
      transform: translateY(-50%);
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #ffffff;
      color: #1f2937;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      transition: transform 0.3s ease, background 0.3s ease, color 0.3s ease;
      box-shadow: 0 6px 18px -8px rgba(15, 23, 42, 0.6);
    }
    body[data-theme="dark"] .theme-toggle .theme-thumb {
      transform: translate(20px, -50%);
      background: #1f2937;
      color: #f8fafc;
    }
    body[data-theme="dark"] .theme-toggle {
      background: rgba(37, 99, 235, 0.2);
      border-color: rgba(37, 99, 235, 0.3);
    }
    main.page {
      max-width: 960px;
      margin: 0 auto;
      padding: 3.5rem 2rem 4.5rem;
    }
    .post-hero {
      position: relative;
      overflow: hidden;
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.22) 0%, rgba(14, 165, 233, 0.08) 60%), var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 28px;
      padding: 2.75rem;
      box-shadow: var(--shadow-lg);
      margin-bottom: 3rem;
    }
    .post-hero::after {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 20% 20%, rgba(59, 130, 246, 0.22) 0%, transparent 55%);
      pointer-events: none;
    }
    .post-hero__icon {
      position: relative;
      font-size: 3.1rem;
      margin-bottom: 1.5rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .post-hero__category {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.4rem 1rem;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.35);
      color: #ffffff;
      font-weight: 600;
      letter-spacing: 0.02em;
      margin-bottom: 1.25rem;
      text-transform: uppercase;
      font-size: 0.8rem;
    }
    .post-hero__title {
      position: relative;
      margin: 0 0 1.25rem;
      font-size: clamp(2.4rem, 4vw, 3.2rem);
      letter-spacing: -0.025em;
      line-height: 1.2;
      color: var(--text-primary);
    }
    .post-hero__meta {
      position: relative;
      display: flex;
      flex-wrap: wrap;
      gap: 1.25rem;
      color: var(--text-muted);
      font-size: 0.95rem;
      font-weight: 500;
    }
    .post-hero__meta span {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
    }
    .post-layout {
      display: grid;
      grid-template-columns: minmax(0, 260px) minmax(0, 1fr);
      gap: 2.5rem;
      align-items: flex-start;
    }
    .post-layout--single {
      grid-template-columns: minmax(0, 1fr);
    }
    .post-toc {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 22px;
      padding: 1.5rem 1.6rem 1.8rem;
      box-shadow: var(--shadow-lg);
      position: sticky;
      top: 120px;
      max-height: calc(100vh - 160px);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .post-toc__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      margin-bottom: 0.5rem;
    }
    .post-toc__title {
      text-transform: uppercase;
      font-size: 0.78rem;
      letter-spacing: 0.18em;
      font-weight: 700;
      color: var(--text-muted);
    }
    .post-toc__toggle {
      display: none;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text-secondary);
      border-radius: 999px;
      padding: 0.25rem 0.8rem;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      align-items: center;
      gap: 0.4rem;
      transition: background 0.2s ease, border 0.2s ease, color 0.2s ease;
    }
    .post-toc__toggle:hover {
      background: rgba(96, 165, 250, 0.15);
      border-color: transparent;
      color: var(--accent);
    }
    .post-toc__content {
      margin-top: 0.6rem;
      overflow-y: auto;
      padding-right: 0.4rem;
      transition: max-height 0.25s ease, opacity 0.25s ease;
      max-height: calc(100vh - 220px);
    }
    .post-toc--collapsed .post-toc__content {
      max-height: 0;
      opacity: 0;
      margin-top: 0;
      pointer-events: none;
    }
    .post-toc__list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
    }
    .post-toc__sublist {
      margin-left: 0.85rem;
      padding-left: 0.85rem;
      border-left: 1px solid rgba(148, 163, 184, 0.35);
      margin-top: 0.4rem;
      gap: 0.35rem;
    }
    .post-toc__item {
      margin: 0;
    }
    .post-toc__link {
      color: var(--text-secondary);
      font-size: 0.95rem;
      line-height: 1.45;
      display: flex;
      align-items: flex-start;
      gap: 0.5rem;
      border-bottom: 1px dashed transparent;
      transition: color 0.2s ease, border-bottom 0.2s ease, transform 0.2s ease;
    }
    .post-toc__link:hover {
      color: var(--accent);
      border-bottom-color: rgba(96, 165, 250, 0.4);
      transform: translateX(2px);
    }
    .post-toc__link--active {
      color: var(--accent-strong);
      border-bottom-color: var(--accent-strong);
    }
    .post-toc__number {
      font-variant-numeric: tabular-nums;
      font-size: 0.85rem;
      color: var(--text-muted);
      min-width: 2.5ch;
      display: inline-flex;
      justify-content: flex-end;
      padding-top: 0.15rem;
    }
    .post-toc__text {
      flex: 1;
    }
    .post-body {
      background: var(--bg-card-strong);
      border: 1px solid var(--border);
      border-radius: 26px;
      padding: 2.5rem;
      box-shadow: var(--shadow-lg);
      font-size: 1.04rem;
      line-height: 1.75;
      color: var(--text-secondary);
    }
    .post-body h2 {
      margin-top: 2.75rem;
      margin-bottom: 1.25rem;
      font-size: clamp(1.9rem, 3vw, 2.35rem);
      color: var(--text-primary);
      letter-spacing: -0.01em;
    }
    .post-body h3 {
      margin-top: 2.2rem;
      margin-bottom: 1rem;
      font-size: 1.5rem;
      color: var(--text-primary);
    }
    .post-body h4 {
      margin-top: 1.8rem;
      margin-bottom: 0.75rem;
      font-size: 1.2rem;
      color: var(--text-primary);
    }
    .post-body p {
      margin-bottom: 1.4rem;
    }
    .post-body .post-warning {
      margin: 2rem 0;
      border-radius: 18px;
      border: 1px solid rgba(250, 204, 21, 0.35);
      background: rgba(254, 243, 199, 0.9);
      color: #4a3b0a;
      padding: 0 1.25rem 1rem;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.35);
    }
    body[data-theme="dark"] .post-body .post-warning {
      background: rgba(253, 230, 138, 0.12);
      border-color: rgba(251, 191, 36, 0.5);
      color: #f6e6b2;
      box-shadow: inset 0 0 0 1px rgba(250, 200, 88, 0.3);
    }
    .post-body .post-warning summary {
      list-style: none;
      cursor: pointer;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 1rem 0;
      color: inherit;
    }
    .post-body .post-warning summary::-webkit-details-marker {
      display: none;
    }
    .post-body .post-warning summary::before {
      content: '‚ö†Ô∏è';
      font-size: 1rem;
    }
    .post-body .post-warning[open] {
      padding-bottom: 1.25rem;
    }
    .post-body .post-warning p:last-child {
      margin-bottom: 0;
    }
    .post-body ul,
    .post-body ol {
      margin: 1.4rem 0 1.4rem 1.4rem;
      padding: 0;
    }
    .post-body li {
      margin-bottom: 0.8rem;
    }
    .post-body a {
      color: var(--accent);
      text-decoration: none;
      border-bottom: 1px solid rgba(96, 165, 250, 0.35);
      transition: color 0.2s ease, border-bottom 0.2s ease;
    }
    .post-body a:hover {
      color: var(--accent-strong);
      border-bottom-color: var(--accent-strong);
    }
    .post-body blockquote {
      margin: 2rem 0;
      padding: 1.5rem 1.75rem;
      border-left: 4px solid var(--accent);
      border-radius: 0 18px 18px 0;
      background: rgba(37, 99, 235, 0.12);
      color: var(--text-primary);
    }
    .post-body code {
      background: var(--code-inline-bg);
      color: var(--code-text);
      padding: 0.2rem 0.45rem;
      border-radius: 6px;
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      font-size: 0.9rem;
    }
    .post-body pre code {
      background: transparent;
      padding: 0;
      display: block;
      font-size: inherit;
      line-height: inherit;
    }
    .hljs {
      color: #e2e8f0;
      background: transparent;
    }
    .hljs-comment,
    .hljs-quote {
      color: #7dd79d;
      font-style: italic;
    }
    .hljs-keyword,
    .hljs-selector-tag,
    .hljs-literal,
    .hljs-name,
    .hljs-strong,
    .hljs-built_in {
      color: #7dd3fc;
      font-weight: 600;
    }
    .hljs-title,
    .hljs-section,
    .hljs-function,
    .hljs-meta .hljs-keyword {
      color: #38bdf8;
      font-weight: 600;
    }
    .hljs-string,
    .hljs-doctag,
    .hljs-addition,
    .hljs-attribute,
    .hljs-template-tag,
    .hljs-template-variable {
      color: #facc15;
    }
    .hljs-number,
    .hljs-symbol,
    .hljs-bullet,
    .hljs-link,
    .hljs-meta,
    .hljs-type {
      color: #f472b6;
    }
    .hljs-variable,
    .hljs-params {
      color: #cbd5f5;
    }
    .post-body pre {
      background: var(--code-block-bg);
      color: var(--code-text);
      padding: 1.2rem 1.4rem;
      padding-right: 3.6rem;
      border-radius: 18px;
      overflow-x: auto;
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      font-size: 0.95rem;
      box-shadow: var(--code-shadow);
      border: 1px solid var(--code-border);
      margin: 2rem 0;
      position: relative;
    }
    .code-copy-btn {
      position: absolute;
      top: 0.75rem;
      right: 0.75rem;
      background: rgba(15, 23, 42, 0.8);
      color: #e2e8f0;
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 999px;
      padding: 0.25rem 0.85rem;
      font-size: 0.85rem;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
    }
    .code-copy-btn:hover {
      background: rgba(96, 165, 250, 0.85);
      color: #ffffff;
      border-color: transparent;
      transform: translateY(-1px);
    }
    .code-copy-btn--copied {
      background: rgba(34, 197, 94, 0.85);
      color: #ffffff;
      border-color: transparent;
    }
    .code-copy-btn__icon {
      font-size: 0.95rem;
    }
    .code-copy-btn__text {
      display: inline-block;
    }
    body[data-theme="light"] .code-copy-btn {
      background: rgba(248, 250, 252, 0.85);
      color: #0f172a;
      border-color: rgba(148, 163, 184, 0.4);
    }
    body[data-theme="light"] .code-copy-btn--copied {
      background: rgba(34, 197, 94, 0.92);
      color: #ffffff;
    }
    .post-body img {
      max-width: 100%;
      border-radius: 18px;
      margin: 2.2rem 0;
      box-shadow: 0 24px 45px -28px rgba(15, 23, 42, 0.55);
    }
    .post-body .table-wrapper {
      margin: 2rem 0;
      border-radius: 18px;
      border: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.55);
      box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.12);
      position: relative;
      overflow: hidden;
    }
    .post-body .table-wrapper__scroll {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }
    .post-body .table-wrapper__scroll::-webkit-scrollbar {
      height: 10px;
    }
    .post-body .table-wrapper__scroll::-webkit-scrollbar-thumb {
      background: rgba(96, 165, 250, 0.4);
      border-radius: 999px;
    }
    .post-body .table-wrapper table {
      width: 100%;
      border-collapse: collapse;
      background: transparent;
    }
    .post-body .table-wrapper[data-table-size="medium"] table {
      min-width: 720px;
    }
    .post-body .table-wrapper[data-table-size="wide"] table {
      min-width: 960px;
    }
    .post-body .table-wrapper thead th {
      background: rgba(96, 165, 250, 0.12);
      color: var(--text-primary);
      font-weight: 600;
    }
    .post-body .table-wrapper th,
    .post-body .table-wrapper td {
      padding: 0.9rem 1rem;
      text-align: left;
      border-bottom: 1px solid rgba(148, 163, 184, 0.18);
      white-space: nowrap;
    }
    .post-body .table-wrapper td {
      white-space: normal;
    }
    .post-body .table-wrapper tr:last-child td {
      border-bottom: none;
    }
    .post-body .table-wrapper__expand {
      position: absolute;
      top: 0.75rem;
      right: 0.75rem;
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.3);
      color: var(--accent);
      border-radius: 999px;
      padding: 0.35rem 0.9rem;
      font-size: 0.85rem;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
      z-index: 2;
    }
    .post-body .table-wrapper__expand:hover {
      background: rgba(37, 99, 235, 0.35);
      color: #ffffff;
      transform: translateY(-1px);
      border-color: transparent;
    }
    .table-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.85);
      backdrop-filter: blur(6px);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      z-index: 999;
    }
    .table-overlay--visible {
      display: flex;
    }
    .table-overlay__content {
      background: var(--bg-card-strong);
      border: 1px solid var(--border);
      border-radius: 24px;
      max-width: min(1080px, 92vw);
      max-height: 85vh;
      width: 100%;
      box-shadow: 0 32px 80px -40px rgba(15, 23, 42, 0.9);
      position: relative;
      overflow: hidden;
    }
    .table-overlay__close {
      position: absolute;
      top: 0.85rem;
      right: 0.85rem;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.35);
      color: var(--text-primary);
      border-radius: 999px;
      padding: 0.4rem 1rem;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease;
    }
    .table-overlay__close:hover {
      background: rgba(37, 99, 235, 0.4);
      color: #ffffff;
      border-color: transparent;
    }
    .table-overlay__scroll {
      overflow: auto;
      max-height: 85vh;
      padding: 2.5rem 2rem 2rem;
    }
    .table-overlay__scroll table {
      width: 100%;
      border-collapse: collapse;
      background: transparent;
    }
    .table-overlay__scroll table[data-table-size="medium"] {
      min-width: 720px;
    }
    .table-overlay__scroll table[data-table-size="wide"] {
      min-width: 960px;
    }
    .table-overlay__scroll thead th {
      background: rgba(96, 165, 250, 0.12);
      color: var(--text-primary);
      font-weight: 600;
    }
    .table-overlay__scroll th,
    .table-overlay__scroll td {
      padding: 0.9rem 1rem;
      text-align: left;
      border-bottom: 1px solid rgba(148, 163, 184, 0.18);
      white-space: nowrap;
    }
    .table-overlay__scroll td {
      white-space: normal;
    }
    .table-overlay__scroll tr:last-child td {
      border-bottom: none;
    }
    body[data-theme="light"] .post-body .table-wrapper {
      background: rgba(255, 255, 255, 0.96);
      box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.16);
    }
    body[data-theme="light"] .post-body .table-wrapper__expand {
      background: rgba(248, 250, 252, 0.9);
    }
    body[data-theme="light"] .table-overlay {
      background: rgba(15, 23, 42, 0.25);
    }
    body[data-theme="light"] .table-overlay__content {
      background: rgba(255, 255, 255, 0.98);
    }
    body.no-scroll {
      overflow: hidden;
    }
    footer {
      margin-top: 4rem;
      padding: 2rem 0;
      text-align: center;
      color: var(--text-muted);
      font-size: 0.92rem;
      border-top: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.35);
    }
    body[data-theme="light"] footer {
      background: rgba(255, 255, 255, 0.72);
    }
    @media (max-width: 1024px) {
      .site-header__inner {
        padding: 1rem 1.5rem;
      }
      main.page {
        padding: 2.75rem 1.5rem 4rem;
      }
      .post-layout {
        grid-template-columns: minmax(0, 1fr);
      }
      .post-toc {
        position: static;
        max-height: none;
        margin-bottom: 2rem;
        padding: 1.25rem 1.35rem 1.5rem;
      }
      .post-toc__toggle {
        display: inline-flex;
      }
      .post-toc__content {
        max-height: none;
        margin-top: 0.4rem;
        overflow: visible;
      }
    }
    @media (max-width: 720px) {
      .post-hero {
        padding: 2.1rem 1.65rem;
      }
      .post-body {
        padding: 1.9rem 1.5rem;
      }
      .site-header__inner {
        flex-direction: column;
        align-items: stretch;
        gap: 1rem;
      }
      .site-header__left {
        justify-content: space-between;
      }
      .header-controls {
        align-self: flex-end;
      }
      .post-hero__title {
        font-size: clamp(2rem, 6vw, 2.6rem);
      }
      .post-body .table-wrapper {
        margin: 1.6rem 0;
      }
      .post-body .table-wrapper__expand {
        top: 0.6rem;
        right: 0.6rem;
        font-size: 0.78rem;
        padding: 0.25rem 0.75rem;
      }
      .table-overlay__scroll {
        padding: 1.8rem 1.25rem 1.5rem;
      }
    }
  </style>
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      },
    };
  </script>
  <script id="mathjax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body data-theme="dark">
  <header class="site-header">
    <div class="site-header__inner">
      <div class="site-header__left">
        <a class="logo" href="../../../index.html">
          <img src="../../../Assets/Logo.png" alt="Mirko Calcaterra logo" class="logo-img">
          <span class="logo-text">Mirko Calcaterra</span>
        </a>
        <nav class="site-nav">
          <a href="../../../index.html" data-it="Home" data-en="Home">Home</a>
          <a href="../../../blog/index.html" data-it="Blog" data-en="Blog">Blog</a>
        </nav>
      </div>
      <div class="header-controls">
        <button class="lang-btn" type="button">EN</button>
        <button class="theme-toggle" type="button" aria-label="Toggle theme">
          <span class="theme-thumb">‚òÄÔ∏è</span>
        </button>
      </div>
    </div>
  </header>
  <main class="page">
    <article class="post">
      <section class="post-hero">
        <div class="post-hero__icon">ü¶Ä</div>
        <span class="post-hero__category">Rust</span>
        <h1 class="post-hero__title">Why Rust Seems Difficult at First (and Why It&#39;s Actually Not)</h1>
        <div class="post-hero__meta">
          <span>üìÖ December 23, 2025</span>
          <span>‚è±Ô∏è 45 min</span>
        </div>
      </section>
      <section class="post-layout">
        <aside class="post-toc" data-collapsed="false">
        <div class="post-toc__header">
          <div class="post-toc__title" data-it="Indice" data-en="Table of contents">Table of contents</div>
          <button class="post-toc__toggle" type="button" aria-expanded="true" aria-label="Hide table of contents">
            <span class="post-toc__toggle-text">Table of contents</span>
            <span class="post-toc__toggle-icon" aria-hidden="true">‚ñæ</span>
          </button>
        </div>
        <div class="post-toc__content">
          <ul class="post-toc__list">
    <li class="post-toc__item" data-depth="0">
          <a class="post-toc__link" href="#introduction">
            <span class="post-toc__number">1</span>
            <span class="post-toc__text">Introduction</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="0">
          <a class="post-toc__link" href="#difficulty-vs-complexity-measuring-the-difficulty-of-a-language">
            <span class="post-toc__number">2</span>
            <span class="post-toc__text">Difficulty vs. Complexity: Measuring the &quot;Difficulty&quot; of a Language</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="0">
          <a class="post-toc__link" href="#the-developers-mental-baggage-implicit-assumptions-to-unlearn">
            <span class="post-toc__number">3</span>
            <span class="post-toc__text">The Developer&#39;s Mental Baggage: Implicit Assumptions to &quot;Unlearn&quot;</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="0">
          <a class="post-toc__link" href="#explicitness-as-a-design-choice">
            <span class="post-toc__number">4</span>
            <span class="post-toc__text">Explicitness as a Design Choice</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="0">
          <a class="post-toc__link" href="#il-compilatore-di-rust-da-nemico-ad-alleato">
            <span class="post-toc__number">5</span>
            <span class="post-toc__text">Il compilatore di Rust: da nemico ad alleato</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="0">
          <a class="post-toc__link" href="#real-difficulties-vs-initial-friction">
            <span class="post-toc__number">6</span>
            <span class="post-toc__text">Real Difficulties vs. Initial Friction</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="0">
          <a class="post-toc__link" href="#the-mental-click-and-long-term-benefits">
            <span class="post-toc__number">7</span>
            <span class="post-toc__text">The &quot;Mental Click&quot; and Long-Term Benefits</span>
          </a>
          
        </li>
  </ul>
        </div>
      </aside>
        <div class="post-body">
          <h2 id="introduction">Introduction</h2>
<p>Rust is often celebrated as one of the &quot;most loved&quot; languages by developers, and for good reasons: it guarantees high performance, memory safety, and a modern ecosystem. Yet, those who approach Rust coming from other languages often find it <strong>daunting and frustrating</strong> in their first attempts. Rust&#39;s learning curve is legendary: some have called it <em>steep</em> - or even &quot;vertical&quot;<a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=each%20other">[1]</a> - and report having &quot;screamed at the compiler&quot; during their initial experiments<a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=Learning%20Rust%20can%20feel%20like,intellectual%20hazing">[2]</a>. Many even wonder if the problem is themselves (&quot;<strong>am I the one who can&#39;t code?</strong>&quot;) when they see error after error from the Rust compiler<a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=The%20borrow%20checker%20will%20make,don%E2%80%99t%20know%20how%20to%20code">[3]</a>.</p>
<p>It&#39;s therefore worth asking: Is Rust truly <strong>intrinsically difficult</strong>, or does it simply require adopting a <strong>different mental model</strong>? In this article, we will explore the idea that Rust <em>seems</em> difficult initially not because it is a poorly designed language (indeed, many argue the opposite<a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=There%E2%80%99s%20a%20reason%20developers%20love,documented">[4]</a>), but because it <strong>challenges habits and assumptions</strong> that developers bring from more permissive languages. We will see what these assumptions are, how Rust systematically breaks them, and how, after the initial &quot;<strong>mental click</strong>,&quot; Rust can transform from an apparently hostile enemy into a trusted ally in daily development.</p>
<p>Ultimately, if you feel frustrated with Rust, the message is: <strong>you are not the problem</strong>. It&#39;s normal to &quot;fight with the compiler&quot; at first, but with a change in perspective, you&#39;ll understand that Rust is no more difficult than other languages - it&#39;s just different. And that difference, once understood, <strong>pays off</strong> with more robust code, fewer bugs, and greater confidence in development.</p>
<h2 id="difficulty-vs-complexity-measuring-the-difficulty-of-a-language">Difficulty vs. Complexity: Measuring the &quot;Difficulty&quot; of a Language</h2>
<p>First of all, what does it truly mean for a programming language to be &quot;difficult&quot;? Often, the <strong>intrinsic complexity</strong> of a language is confused with the <strong>perceived difficulty</strong> in learning it. We can distinguish various types of complexity/difficulty:</p>
<ul>
<li><strong>Syntactic complexity:</strong> how intricate or verbose the language is in terms of symbols, keywords, and grammatical rules.</li>
<li><strong>Conceptual complexity:</strong> how many new or unfamiliar concepts need to be learned (e.g., explicit memory management, concurrency models, advanced type system).</li>
<li><strong>&quot;Operational&quot; complexity:</strong> how difficult it is to translate intentions into working code - for example, how much &quot;effort&quot; is needed to obtain a correct and performant program, or for debugging/refactoring.</li>
</ul>
<p>Rust is often labeled as &quot;difficult&quot; because it excels in some of these dimensions: it has a syntax rich in symbols (, &lt;&#39;a&gt;, &amp;mut, ::, etc.), introduces new concepts like <em>ownership/borrowing</em> and lifetimes, and is inflexible in its operation (if everything isn&#39;t perfectly correct, it won&#39;t compile). But this is a partial view.</p>
<p>It&#39;s important to put Rust&#39;s learning curve into perspective. Learning a language <strong>doesn&#39;t</strong> just mean learning its basic syntax, but also its idioms, the standard library model, and common design practices<a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html#:~:text=Let%E2%80%99s%20first%20start%20by%20stating,not%20months%2C%20of%20frequent%20practice">[5]</a>. Languages like Python or Go have an essential syntax that &quot;can be learned in a day,&quot; but <strong>still require months</strong> to master idioms and libraries productively<a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html#:~:text=learning%20its%20syntax,not%20months%2C%20of%20frequent%20practice">[6]</a>. In this sense, Rust is not so different: it might require a few more days to grasp the basics, but in the <strong>grand scheme of time</strong> needed to become proficient, this initial difference is amortized<a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html#:~:text=When%20seen%20through%20these%20lenses%2C%20the%20extra%20days%20of%20learning%20are%20amortized">[7]</a>. In short, <strong>all</strong> languages require time and practice; Rust simply requires a bit more at the beginning, welcoming you with more information and constraints upfront, instead of letting you discover them only later.</p>
<p>A common mistake is to compare Rust to so-called &quot;easy&quot; languages by looking only at first-day productivity. For example, Go or Python allow you to write a working script after a few hours, while with Rust you might get bogged down by borrow checker errors. But that doesn&#39;t mean that after three months of use Go is &quot;easier&quot; than Rust - it just means that those languages <strong>deceive you into feeling productive immediately</strong>, perhaps at the cost of producing suboptimal or non-robust code at first<a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html#:~:text=The%20problem%20is%20that%20simpler,can%20be%20deployed%20or%20released">[8]</a>. The first quick program written in an &quot;easy&quot; language is often far from production software standards<a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html#:~:text=The%20problem%20is%20that%20simpler,can%20be%20deployed%20or%20released">[8]</a>. Rust, on the other hand, asks you to think more at the beginning, so that <strong>the code you write, once compiled, tends to be solid already</strong>.</p>
<p>Another useful perspective: <em>Rust is not difficult in an absolute sense, but it &quot;shifts&quot; the difficulty to different aspects</em>. It requires thinking at a level closer to the computer than high-level languages. In other words, Rust <strong>asks you to understand what happens under the hood</strong> - memory management, concurrency, types - right from the start<a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html#:~:text=Let%E2%80%99s%20now%20take%20a%20different,1">[9]</a>. Many programmers today (especially those trained with languages like Python, Java, C#, or JavaScript) have never had to worry about how memory allocation works or what truly happens in a thread, because they lived in a world with garbage collectors, runtimes, and abstractions that <em>hide</em> these details<a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html#:~:text=memory%20allocation%20and%20concurrency,1">[10]</a>. Rust falls into the more traditional vein of system languages: no garbage collector; resources managed with scoping rules (similar to RAII in C++); no shortcuts to avoid data races except through strict rules of aliasing and mutability<a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html#:~:text=Rust%20falls%20in%20the%20more,computer%E2%80%99s%20processor%20and%20memory%20model">[11]</a>. Consequently, <em>if you have a solid background in C/C++</em>, Rust won&#39;t seem so alien to you - a modern C++ developer accustomed to smart pointers and RAII will likely find Rust <strong>quite natural</strong><a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html#:~:text=My%20take%20on%20this%3A%20for,in%20a%20more%20troublesome%20spot">[12]</a>. But a developer who has only used garbage-collected languages will have to learn concepts they previously completely ignored<a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html#:~:text=My%20take%20on%20this%3A%20for,in%20a%20more%20troublesome%20spot">[12]</a>. The good news is that these concepts (how memory works, what a race condition is, etc.) <strong>can be learned</strong>, and indeed learning them will make you a better programmer even in other languages<a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html#:~:text=The%20good%20thing%20is%20that,language%20you%20write%20code%20in">[13]</a>. In other words, Rust &quot;forces&quot; you into an accelerated course on computer science fundamentals that you might otherwise postpone - and it&#39;s normal for this to seem difficult, but it&#39;s an investment that is always worthwhile.</p>
<p>In summary, when we say Rust is difficult, we must ask ourselves: is it truly <em>more complex</em> than other languages, or is it simply bringing to light complexities that are hidden elsewhere? Often, the latter is true. The corollary is that judging Rust by the same metrics we use for a scripting language risks being misleading<a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html#:~:text=The%20problem%20is%20that%20simpler,can%20be%20deployed%20or%20released">[8]</a>. Rust makes a trade-off: it <strong>demands more rigor from the programmer</strong>, but in return offers more compiler assistance and fewer runtime surprises. To paraphrase a famous saying by Bjarne Stroustrup, creator of C++: <em>&quot;There are two kinds of languages: those that people complain about, and those that nobody uses&quot;</em>. The fact that many find Rust arduous at first is not a damning verdict - it&#39;s almost a mark of the language&#39;s growth and ambition<a href="https://mmapped.blog/posts/15-when-rust-hurts#:~:text=,Bjarne%20Stroustrup">[14]</a><a href="https://mmapped.blog/posts/15-when-rust-hurts#:~:text=Yet%2C%20I%20often%20find%20myself,is%20perfect%20for%20every%20problem">[15]</a>.</p>
<h2 id="the-developers-mental-baggage-implicit-assumptions-to-unlearn">The Developer&#39;s Mental Baggage: Implicit Assumptions to &quot;Unlearn&quot;</h2>
<p>To understand why Rust challenges so many programmers, we must examine the &quot;<strong>mental baggage</strong>&quot; we carry from other languages. Every programming language creates expectations in its users about how things <em>should work</em>. Rust, with its rules, <strong>intentionally violates many of these expectations</strong>, forcing us to rethink how we design code. Here are some common assumptions that Java, Python, JavaScript, C# (and partly C/C++) developers might have - and how Rust refutes them:</p>
<ul>
<li><p><strong>&quot;Memory management is not my concern.&quot;</strong> In languages with a <em>garbage collector</em> (Java, C#, Go, JavaScript, etc.), the developer allocates objects freely, and an automatic system frees them in the background when they are no longer needed. In Rust, there is no GC<a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html#:~:text=Rust%20falls%20in%20the%20more,computer%E2%80%99s%20processor%20and%20memory%20model">[11]</a>: memory is managed through <em>ownership</em> and <em>scope</em>. This means you must explicitly think about <strong>who owns a piece of data and for how long</strong>, because as soon as it goes out of scope, it is automatically released. For those coming from GC languages, it&#39;s a shock: &quot;wait, I have to worry about this string going out of scope?&quot; In reality, Rust does this automatically, but <em>only</em> if the ownership rules are respected; if you try to violate them (for example, by returning a reference to a value that goes out of scope), the compiler will stop you. Thus, Rust forces you to <strong>consider the lifetime of resources</strong> from the very design of functions, something you weren&#39;t used to elsewhere.</p>
</li>
<li><p><strong>&quot;Assigning or passing variables around is harmless.&quot;</strong> Those coming from Python/Java think that <code>x = y</code> copies a reference and leaves <code>y</code> intact, or at least that passing a variable to a function will not <strong>invalidate</strong> it upon return. In Rust, on the contrary, assigning or passing a value <strong>moves</strong> the ownership of that value, unless the type is <code>Copy</code>. For example: <code>let s = String::from(&quot;hello&quot;); let s2 = s;</code> - after these two lines, <code>s</code> is no longer usable, because the <em>String</em> has been moved to <code>s2</code><a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=let%20s%20%3D%20String%3A%3Afrom%28,now%20s%20is%20invalid">[16]</a>. In many languages, this concept doesn&#39;t exist (the object would remain shared or there would be a default copy); in Rust, however, it is the default behavior. At first, it seems like Rust treats variables &quot;like radioactive waste that you can only touch once&quot;<a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=What%20just%20happened%3F%20You%20didn%E2%80%99t,can%20only%20be%20touched%20once">[17]</a>, but in reality, it is preventing uncontrolled aliasing and unexpected memory duplications. It&#39;s up to you to decide when to explicitly clone data - making the cost <em>visible</em> in the code - rather than letting the language make silent copies. This is a major difference in mindset.</p>
</li>
<li><p><strong>&quot;I can have multiple references to an object and modify everything freely.&quot;</strong> In traditional OO languages, it&#39;s normal to have multiple aliases to the same object (e.g., different variables pointing to the same array/dictionary) and modify the object through any of these references. Rust, however, imposes very strict aliasing rules: you either have a single mutable reference, <em>or</em> you can have multiple immutable references, but not both simultaneously. You cannot modify something if someone else is reading a copy of it, and vice versa, under penalty of a compilation error. This restriction - which initially seems excessive - actually eliminates entire categories of bugs (data races, concurrent invalidations, invalid iterators, etc.). But for those coming from environments where &quot;everything is a reference and I&#39;ll take care not to mess things up,&quot; it&#39;s a drastic change: Rust doesn&#39;t &quot;trust&quot; you and forces you to clearer designs about who writes and who reads a certain resource at a given moment.</p>
</li>
<li><p><strong>&quot;Exceptions handle errors; I don&#39;t need to check for them everywhere.&quot;</strong> Many languages use <em>exceptions</em> to signal runtime errors: if something goes wrong, an exception is thrown that can propagate up the stack until it is caught (or not). In these languages, the error flow is <strong>implicit</strong>: a function can fail and throw something without explicitly declaring it in its signature (unless mechanisms like Java&#39;s throws are used, which are often bypassed with runtime exceptions). Rust, however, adopts a totally different approach: errors are values, represented by Result&lt;T, E&gt;. There is no undeclared exception mechanism: if a function can fail, it must return a Result (or panic, but <em>panic</em> in Rust is reserved for exceptional and unrecoverable conditions). Many coming from Java/C# initially treat Result as if it were just &quot;a different syntax for doing exceptions,&quot; but this mental model <strong>does not work</strong> and leads to great frustration<a href="https://medium.com/rustaceans/rust-errors-arent-exceptions-87ce365d4dff#:~:text=Only%20panic%20when%20necessary">[18]</a>. In Rust, you are forced to think of the error as part of the normal program flow (thus <em>explicitly stating it</em> with the return type) and to handle it where you would have otherwise ignored a possible exception. This is one of the most evident frictions for those coming from languages with exceptions: that feeling of &quot;verbosity&quot; in Rust (checking every result, using ? or match to propagate/handle errors) is not accidental, but a deliberate design to ensure greater reliability. As one developer aptly summarizes: <em>&quot;one of the most common mistakes is bringing the idea to Rust that Result is just a verbose way of doing exceptions - that mental model breaks immediately and the friction you feel is not a flaw in Rust, it&#39;s a signal that something conceptually different lies beneath&quot;</em><a href="https://medium.com/rustaceans/rust-errors-arent-exceptions-87ce365d4dff#:~:text=Only%20panic%20when%20necessary">[18]</a>. In Rust, <strong>an error is data, not an event</strong><a href="https://medium.com/rustaceans/rust-errors-arent-exceptions-87ce365d4dff#:~:text=Only%20panic%20when%20necessary">[18]</a> - understanding this completely changes the approach to robust programming.</p>
</li>
<li><p><strong>&quot;Language X is object-oriented, Rust will be too.&quot;</strong> Those coming from Java, C#, or even Python (which, while not exclusively OOP, makes extensive use of classes) might approach Rust trying to reproduce classic OO patterns: inheritance, class hierarchies, designs based on mutable objects with internal methods, getters/setters, etc. Rust is <em>not</em> a strictly OOP language - it supports some aspects (you can have methods associated with structs, implement traits which are somewhat like interfaces, etc.), but it lacks classic inheritance and discourages certain patterns typical of Java. This <strong>heavily influences</strong> how you structure programs and what you need to pay attention to<a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=Rust%20isn%27t%20object,are%20not%20natural%20in%20Rust">[19]</a>. For example, in Java it&#39;s common to model <em>parent-child</em> relationships between objects (e.g., an Employee extending Person), whereas in Rust you would probably use composition or enum variants, avoiding sharing complex mutability between structs. A Java programmer might ask &quot;where is my globally mutable ArrayList? where is my inheritance to specialize this class?&quot;, and Rust&#39;s answer will be: you don&#39;t have them as you know them - you have to &quot;think differently&quot;. This is initially disorienting (a true <em>culture shock</em> as someone notes<a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=I%20am%20an%20engineer%2C%20yes,language%20is%20JavaScript%20or%20Python">[20]</a>), but it leads to coding problems in alternative ways, often safer and more predictable.</p>
</li>
</ul>
<p><strong>&quot;The runtime will handle the details (IO, threads, etc.).&quot;</strong> High-level languages often heavily abstract the underlying system. For example, in Python, you can create threads without worrying about <em>shared memory</em> because the interpreter has the GIL; in Java, you start threads or async tasks relying on the GC and JVM to manage scheduling and shared memory (except for synchronizations). Rust, on the other hand, directly exposes many details: if you do asynchronous concurrent programming, you need to know what a Future is and that it doesn&#39;t start on its own without an <em>executor</em>; you must ensure that data shared between threads implements Send and Sync (the compiler enforces this otherwise) and perhaps explicitly use Arc&lt;Mutex&lt;T&gt;&gt; for safe mutual sharing. In short, <strong>you realize you have to &quot;micro-manage&quot; aspects that were implicit elsewhere</strong><a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=">[21]</a>. This can make Rust seem inconvenient for certain things (for example, <em>async</em> programming in Rust is notoriously more verbose and rigid than in Python/JavaScript, where &quot;just&quot; using async/await is enough - in Rust you also need to understand future <em>lifetimes</em>, the Send trait for async move, etc. <a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i_survived-459082669e91#:~:text=Rust%E2%80%99s%20async%20model%20is%20powerful%2C,and%20pinning">[22]</a>). In reality, once again, Rust forces you to confront real complexities (concurrency, multithreading) from the outset - &quot;you tackle performance from the very beginning,&quot; says one user comparing it to Java<a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=The%20result%20is%20really%20worth,it%20from%20the%20very%20beginning">[23]</a> - whereas elsewhere you might ignore them until hard-to-diagnose bugs emerge.</p>
<p>This list could go on, but the key point is: <em>many initial frustrations with Rust stem from trying to use the same mental habits in Rust as before</em>. As a Java developer admitted after initial attempts: the main problem at first was <strong>&quot;trying to write in Rust as I would have written in Java,&quot;</strong> a mistake that led to constantly getting stuck<a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=As%20a%20Java%20developer%20playing,would%20have%20written%20with%20Java">[24]</a>. Only when he accepted that Rust &quot;is not Java&quot; and requires a different way of thinking - <strong>more careful, more explicit, considering low-level aspects that the JVM concealed</strong> - did he begin to make progress<a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=As%20a%20Java%20developer%20playing,would%20have%20written%20with%20Java">[24]</a>. In Rust, you have to unlearn certain shortcuts or expectations: there&#39;s no &quot;throw NullPointerException and I&#39;ll handle it later,&quot; because in Rust you simply avoid <em>null</em> altogether; you can&#39;t assume a function will &quot;magically&quot; return what you want if it can fail - you must handle its failure. At first, this is tiring and can make Rust seem to <em>complicate</em> everything unnecessarily. But as we will see, there&#39;s a reason for every apparent complication.</p>
<p>Before moving on, it&#39;s worth noting a curious phenomenon: <strong>sometimes junior developers learn Rust more easily than veterans</strong>. This is because, lacking decades of established habits, newcomers can adapt to Rust&#39;s model more quickly, while those with long experience in other languages might have to &quot;fight their instincts&quot; longer<a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=Your%20learning%20pace%20doesn%E2%80%99t%20have,your%20attitude%20toward%20the%20language">[25]</a>. As one engineer observes: he has seen juniors with no prior experience excel in Rust, while acclaimed senior developers struggle or even give up, due to hubris or the difficulty in questioning their mental patterns<a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=I%20have%20seen%20junior%20devs,Leave%20your%20hubris%20at%20home">[26]</a>. In Rust, those who know how to <em>learn to learn</em> win, those who accept returning to being a beginner and &quot;leaving their ego at home&quot;<a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=I%20have%20seen%20junior%20devs,Leave%20your%20hubris%20at%20home">[26]</a>. So if you find Rust difficult and have been programming for years, know that it&#39;s normal: you are reforging your way of thinking, and a few years of experience elsewhere might prove less useful than expected until you realign your mindset.</p>
<h2 id="explicitness-as-a-design-choice">Explicitness as a Design Choice</h2>
<p>Many of Rust&#39;s differences can be summarized in one principle: <strong>explicit is better than implicit</strong> (sound familiar? It&#39;s one of Python&#39;s language design principles, curiously - but Rust takes it to even greater consequences). Rust&#39;s authors have made precise choices <em>not</em> to automatically do certain things that other languages do behind the scenes, forcing the programmer to formally declare their intentions in the code. This can initially give the impression of &quot;ceremony&quot; or excessive verbosity, but it is designed to prevent surprises and increase clarity and safety.</p>
<p>We have already seen examples of explicitness: mutability must be declared with <code>mut</code> otherwise everything is immutable; type conversions do not happen implicitly (Rust will not convert a <code>u32</code> to <code>usize</code> or a <code>String</code> to <code>&amp;str</code> without you explicitly saying so); error handling is in the function signature; mutable sharing between threads requires explicit constructs (<code>Arc</code>/<code>Mutex</code>). To these we can add: no <em>implicit type coercion</em> (every cast must be explicit, to avoid unexpected data loss), no magical default initializations (you must initialize variables before use, there is no concept of default uninitialized that becomes a bug if forgotten), and so on. Even advanced features like <em>trait objects</em> in Rust require explicit syntax (Box&lt;dyn Trait&gt;) instead of automatically performing <em>boxing</em> or <em>virtual dispatch</em> without you noticing.</p>
<p>Why all this emphasis on explicitness? <strong>Because it eliminates ambiguity and empowers the programmer</strong>. When you read Rust code, you clearly see what is happening: which variables can change and which cannot, where an error might occur, who owns a certain piece of data and for how long. In more permissive languages, you often have to <em>deduce</em> these aspects (and sometimes you deduce them incorrectly, causing bugs). Rust forces you to write them down explicitly. This certainly involves more characters to type and more concepts to handle, but it produces code that, once compiled, <strong>is very reliable</strong>.</p>
<p>A neutral comparison: Python is notoriously concise and &quot;elegant,&quot; while Rust can seem verbose or &quot;ugly&quot; to those coming from dynamic languages<a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=If%20you%20come%20from%20a,scale%20applications">[27]</a>. It is true that a Rust program has more annotations (generic types <code>&lt;T&gt;</code>, lifetimes <code>&lt;&#39;a&gt;</code>, etc.) compared to a Python equivalent. But that verbosity serves a purpose. As an expert explains, <strong>Rust&#39;s verbosity has concrete benefits in large-scale development</strong><a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=If%20you%20come%20from%20a,scale%20applications">[27]</a>. First, readability: you will spend more time <em>reading</em> code (yours or others&#39;) than writing it, and having types and mutability visible in the code gives you more local context to reason about what a function is doing<a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=,because%20the%20compiler%20can%20check">[28]</a>. Second, it facilitates <em>refactoring</em>: if you want to modify the structure of a Rust program, the compiler will guide you by highlighting every point where you need to make changes (because if you forget to update a usage, it simply won&#39;t compile)<a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=,dismiss%20the%20language%20right%20away">[29]</a>. In dynamic languages or those with fewer controls, you can rename a function or change the type of an argument, breaking ten calls in other parts of the code and not noticing until runtime (or never, if that part of the code is not well covered by tests). In Rust, however, <strong>the compiler is your safety net</strong> during refactoring: as long as everything doesn&#39;t compile again, you know you have fixed every necessary point. This encourages continuous code improvement without fear of introducing regressions.</p>
<p>One aspect where Rust&#39;s explicitness is evident is memory and resource management. We mentioned that Rust does not perform periodic automatic cleanup like a GC ‚Äì instead, it uses the ownership system to free resources as soon as they go out of scope. Here too, Rust prioritizes predictability: deallocation is <strong>deterministic</strong> and visible from the context (you know that at the end of that block, that object is released). This avoids an entire class of problems like non-deterministic GC stop times, but it implies that you must think about the lifetimes of data. In practice, Rust only asks you to specify lifetimes when it cannot figure them out on its own: this is another example of the balance between implicit and explicit. Often the compiler can infer lifetimes, but if there&#39;s ambiguity, it will give you an error asking you to specify them yourself<a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=If%20you%20try%20to%20compile,It%20provides%20this%20helpful%20suggestion">[30]</a>. The error message typically says something like <em>&quot;this function needs an explicit lifetime parameter&quot;</em> and might even show you how to add it<a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=If%20you%20try%20to%20compile,It%20provides%20this%20helpful%20suggestion">[30]</a>. At that moment, it is <strong>teaching</strong> you something: if you think about it, why can&#39;t the compiler infer that lifetime? Perhaps the relationship between the returned references is not obvious, and by specifying <code>fn foo&amp;lt;&#39;a&amp;gt;(x: &amp;&#39;a str) -&gt; &amp;&#39;a str</code> you are making it clear to yourself and others that the output lives as long as the input lives. This is an example of how Rust makes you explicit not out of sadism, but to make <strong>dependencies crystal clear</strong> and prevent undesirable behavior. As one author suggests, it&#39;s useful <em>&quot;not just to follow the compiler&#39;s instructions, but to ask</em> why <em>it needs that information&quot;</em><a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=So%20you%20don%E2%80%99t%20have%20to,couldn%E2%80%99t%20figure%20it%20out%20itself">[31]</a>: often you&#39;ll find you&#39;re learning something about the design of your functions.</p>
<p>Ownership, mutability, lifetimes, explicit error handling ‚Äì all these design choices reflect a philosophy: <strong>the language prefers you to declare things, rather than it guessing them for you</strong>. A further advantage of this approach is that it <strong>trains you for precision</strong>. In other languages, you can afford to be &quot;approximate&quot; or negligent about certain things (e.g., using an uninitialized variable, forgetting to close a file, not considering an error case) and the program still runs, only to perhaps fail in unexpected ways at runtime. Not in Rust ‚Äì <em>&quot;you can be sloppy in other languages, but not in Rust&quot;</em><a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=,%E2%80%93%20An%20ancient%20Rust%20proverb">[32]</a>. Rust forces you to be accurate during writing, or the code simply won&#39;t compile<a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=You%20can%20be%20sloppy%20in,debugging%20time%20in%20the%20future">[33]</a>. This might seem like a drag on productivity (&quot;darn, I have to pay attention to every detail!&quot;), but the idea is that all the care you put in upfront to satisfy the compiler <strong>saves you time later</strong> in debugging and bug hunting<a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=,%E2%80%93%20An%20ancient%20Rust%20proverb">[32]</a>. As an (apocryphal) proverb cited in an article says: <em>&quot;how you do anything is how you do everything&quot;</em>, indicating that attention to detail while writing Rust code accustoms you to a discipline that will then pay dividends generally<a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=,%E2%80%93%20An%20ancient%20Rust%20proverb">[32]</a>. It&#39;s as if Rust asks you: would you rather spend two hours now figuring out why the borrow checker won&#39;t let you do this, or two days a month from now debugging a segfault/unspecified crash in production? Would you rather add an error case now, or receive a call at 3 AM because an unhandled exception brought down the service? Rust makes you <strong>pay technical debt upfront</strong>, forcing you to write more complete and correct code right from the start.</p>
<p>Un esempio concreto di &quot;costo di cerimonia&quot; di Rust che √® anche un beneficio in incognito: in molti linguaggi puoi riutilizzare la stessa variabile pi√π volte senza pensarci; in Rust, se vuoi riutilizzare un valore dopo averlo passato, magari devi fare una copia esplicita con .clone(). Questo all&#39;inizio pare noioso - &quot;perch√© devo scrivere .clone()? non potrebbe fare da solo una copia quando serve?&quot;. Ma Rust ti sta chiedendo: <em>sei sicuro di voler fare una copia? sai che questo ha un costo di performance?</em> Ti obbliga a considerarlo. Uno sviluppatore ha notato proprio questo quando cercava di rifattorizzare del codice: estrarre una variabile temporanea e usarla due volte portava a un errore, perch√© il tipo non implementava la copia implicita, e ha dovuto inserire un .clone() esplicito<a href="https://mmapped.blog/posts/15-when-rust-hurts#:~:text=However%2C%20our%20first%20naive%20version,write%20the%20following%20expression%20instead">[34]</a>. Commenta: <em>possiamo vederla in positivo se ci interessa la performance, perch√© copiare memoria √® diventato un atto esplicito; ma rimane un po&#39; fastidioso nella pratica</em><a href="https://mmapped.blog/posts/15-when-rust-hurts#:~:text=let%20s%20%3D%20,to_string%28%29%3B%20f%28s.clone%28%29%29%3B%20g%28s">[35]</a>. Ecco, quel &quot;fastidio&quot; √® il tipico attrito iniziale - √® Rust che ti obbliga alla best practice (non duplicare dati inconsapevolmente) anche quando tu magari non te ne cureresti. Sul momento ti irrita, col tempo <strong>ti accorgi che √® stata una lezione</strong> e inizi a pensarci da solo.</p>
<p>In sintesi, l&#39;esplicitezza di Rust √® una scelta di design consapevole che rispecchia la sua &quot;personalit√†&quot; severa ma giusta. Pu√≤ far apparire Rust pi√π complesso sulla carta (pi√π parole chiave, pi√π annotazioni, pi√π regole da seguire), ma ciascuno di questi apparenti fardelli √® l√¨ per uno scopo. E soprattutto, una volta interiorizzati, <strong>smettono di essere fardelli</strong>. Un programma Rust idiomatico a un occhio allenato risulta chiaro e pulito quanto (se non pi√π) di un programma Python, solo che richiede di <em>allenare</em> quell&#39;occhio. Per arrivarci, per√≤, bisogna prima superare una fase in cui sembra di affogare nei dettagli: ed √® qui che entra in gioco il ruolo del compilatore come guida.</p>
<h2 id="il-compilatore-di-rust-da-nemico-ad-alleato">Il compilatore di Rust: da nemico ad alleato</h2>
<p>Molti sviluppatori, nei primi giorni con Rust, vivono un rapporto di amore-odio col <strong>compilatore</strong>. Pi√π odio che amore, a dire il vero. I messaggi di errore di Rust sono famosi per la loro lunghezza e meticolosit√† nel descrivere cosa c&#39;√® che non va. Un novizio li vede comparire a dozzine e pu√≤ avere l&#39;impressione che il compilatore sia <strong>ostile</strong>, quasi <em>punitivo</em>. Non a caso si parla di &#39;<em>fighting the compiler</em>&#39; - combattere il compilatore, o nello specifico &#39;<em>fighting the borrow checker</em>&#39;. Chi arriva da linguaggi permissivi, dove magari il compilatore (se c&#39;√®) si lamenta poco e lascia che il programma giri fino a che <em>runtime</em> non esplode qualcosa, trova sconvolgente un compilatore che sembra voler impedire di scrivere anche le cose pi√π banali. C&#39;√® una famosa vignetta (diventata meme tra i Rustacei) che personifica il compilatore Rust come un severo insegnante che bacchetta lo studente per ogni minimo errore, contro l&#39;insegnante di altri linguaggi che invece lascia passare anche scemenze salvo poi far fare brutta figura all&#39;esame (il runtime).</p>
<p>Initially, <strong>it&#39;s normal to perceive the compiler as an enemy</strong>. &quot;I write a function that would work in any other language, and Rust spits out three paragraphs of angry diagnostics,&quot; says one developer, &quot;and when I think I&#39;ve fixed it, it throws a different error&quot;<a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=The%20borrow%20checker%20will%20make,don%E2%80%99t%20know%20how%20to%20code">[3]</a>. Frustration mounts, and you feel incompetent. Another testifies: <em>&quot;I spent entire afternoons on a single lifetime annotation&quot;</em>, or rewrote data structures because &quot;the compiler wouldn&#39;t let me have two mutually referencing fields&quot;<a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=You%20start%20second">[36]</a>. This feeling of being constantly reprimanded leads many to <strong>shout at the compiler</strong> or describe it in unflattering ways. If you feel this way, know that you&#39;re in good company: almost all Rustaceans have gone through it at the beginning (anyone who says they haven&#39;t is probably lying). As one article recalls, <em>&quot;we&#39;ve all yelled at least once &#39;why won&#39;t you let me do this stupid thing, you cursed compiler!&#39;&quot;</em> during the learning phase<a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=Learning%20Rust%20can%20feel%20like,intellectual%20hazing">[2]</a><a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=The%20borrow%20checker%20will%20make,don%E2%80%99t%20know%20how%20to%20code">[37]</a>.</p>
<p>The turning point, however, comes when you realize that wall of errors is actually <strong>an instruction panel</strong>. The Rust compiler, though strict, is also extraordinarily <em>educational</em>. Its messages don&#39;t just say &quot;this is wrong&quot;; they often explain <strong>why</strong> it&#39;s wrong and suggest how to fix it<a href="https://ferrous-systems.com/blog/the-compiler-is-your-friend/#:~:text=error,cannot%20borrow%20as%20mutable">[38]</a><a href="https://ferrous-systems.com/blog/the-compiler-is-your-friend/#:~:text=The%20compiler%20gives%20us%20an,the%20affected%20variable%20is%20underlined">[39]</a>. For example, you might see: <em>&quot;cannot borrow foo as mutable because it is not declared as mutable‚Ä¶ help: consider changing this to mut foo&quot;</em><a href="https://ferrous-systems.com/blog/the-compiler-is-your-friend/#:~:text=error,cannot%20borrow%20as%20mutable">[38]</a><a href="https://ferrous-systems.com/blog/the-compiler-is-your-friend/#:~:text=The%20compiler%20gives%20us%20an,the%20affected%20variable%20is%20underlined">[39]</a>. Or: <em>&quot;use of moved value x‚Ä¶ value moved here‚Ä¶ help: consider cloning the value&quot;</em>. In short, the compiler practically <strong>debugs with you</strong>. At first, you might not notice, overwhelmed by the terminology, but gradually you start reading those messages more calmly and realize they contain the key to progress. A crucial piece of advice is precisely this: <em>read them carefully, almost as if they were documentation</em><a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=Here%E2%80%99s%20what%20finally%20made%20the,difference">[40]</a>. Don&#39;t treat the error as an enemy to silence, but as a patient colleague explaining what to fix<a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=Here%E2%80%99s%20what%20finally%20made%20the,difference">[40]</a>. One author puts it illuminatingly: &quot;treat the borrow checker as a co-author, not an adversary&quot;<a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=Treat%20the%20borrow%20checker%20as,couldn%E2%80%99t%20figure%20it%20out%20itself">[41]</a>. This simple psychological reframing changes the experience: the compiler isn&#39;t there to make you fail, but to <em>teach</em> you how to do better. In fact, especially with concepts like lifetimes, let the compiler <em>tell</em> you where there&#39;s ambiguity and what it needs<a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=Treat%20the%20borrow%20checker%20as,couldn%E2%80%99t%20figure%20it%20out%20itself">[42]</a><a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=If%20you%20try%20to%20compile,It%20provides%20this%20helpful%20suggestion">[30]</a>: by following its suggestions, you learn exactly what the rules of the game are.</p>
<p>Many Rust veterans testify that at some point your relationship with the compiler makes a U-turn. <strong>The more you learn to trust it, the more it will trust you back.</strong> There&#39;s a post on the official forum that reads: &quot;As soon as you realize the compiler is your friend (not your enemy), you start to be thankful for every error&quot;<a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=My%20first%20step%20was%20reading,be%20thankful%20for%20every%20error">[43]</a>. This is exactly the change in mindset: from &quot;ugh, more errors!&quot; to &quot;thank goodness this error came up now, so I avoided a bug later.&quot; You go from seeing the compiler as a gatekeeper blocking the door, to seeing it as a <strong>safety net</strong> under the trapeze artist: it prevents you from falling by pointing out errors before they become real problems. One user comments: &quot;at first you hate the compiler, then you love it&quot;<a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=The%20compiler%20is%20great%20at,you%20get%20used%20to%20it">[44]</a>. Another writes: &quot;trust me, later on you&#39;ll thank every single error message&quot;<a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=My%20first%20step%20was%20reading,be%20thankful%20for%20every%20error">[43]</a>.</p>
<p>It&#39;s worth emphasizing <em>how much</em> the Rust compiler is actually different from others. It&#39;s not marketing: Rust&#39;s messages are notoriously more descriptive and helpful than those of, for example, C++ or Java. This is the result of a conscious effort by the Rust community since its inception ‚Äì some jokingly say that Rust has <em>&quot;the UX team for error messages&quot;</em>. In fact, over the years, the messages have improved to the point that they often directly suggest the correction. There are blogs that show the evolution of Rust errors: from cryptic phrases to almost prose-like explanations<a href="https://news.ycombinator.com/item?id=44005195#:~:text=Evolution%20of%20Rust%20Compiler%20Errors,explanation%20of%20why%20it%27s%20wrong">[45]</a>. The goal is to make the compiler a <strong>teaching tool</strong> and not just a judge. A fitting example: during learning, many make mistakes in specifying lifetimes or generic types; the compiler not only flags the error but often indicates <em>where</em> and <em>how</em> to add the missing lifetime, complete with a suggested code snippet<a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=If%20you%20try%20to%20compile,It%20provides%20this%20helpful%20suggestion">[30]</a>. This is equivalent to having a tutor over your shoulder telling you &quot;put &#39;a here and here, and think about why it&#39;s needed.&quot; In a sense, using Rust is like taking an intensive course in systems programming with a strict but incredibly knowledgeable teacher: at first, you feel constantly scolded, but if you listen to the &quot;scoldings,&quot; you learn a lot in a short time.</p>
<p>To make the most of this dynamic, you need to &quot;lower your defenses.&quot; Remember the discussion about ego? If you confront the compiler head-on, thinking &quot;I know what I want to do, why are you hindering me!&quot;, you&#39;ll only get frustrated. Instead, it&#39;s useful to adopt humility and curiosity: <strong>why</strong> won&#39;t Rust let me do this? What exactly is the error telling me? Often you&#39;ll discover that the compiler is pointing out a real problem in your code, perhaps a design flaw as someone suggests<a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=Most%20of%20the%20time%20when,do%20it%20the%20Rust%20way">[46]</a>. A common example: when you find yourself writing code that is too convoluted or full of clones to satisfy the borrow checker, it often means you should rethink the structure ‚Äì perhaps you&#39;re trying to do something unidiomatic or overly complex, and Rust is pushing you towards a simpler solution<a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=Most%20of%20the%20time%20when,do%20it%20the%20Rust%20way">[46]</a>. A recurring motto is: <em>&quot;if the code becomes ugly or verbose, declare defeat and redo it the Rust way&quot;</em><a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=Most%20of%20the%20time%20when,do%20it%20the%20Rust%20way">[46]</a>. The compiler is like a compass: if you&#39;re &quot;struggling&quot; too much against it, it&#39;s probably indicating that there&#39;s a cleaner path.</p>
<p>Un ulteriore aiuto viene dagli strumenti satellite come <strong>Clippy</strong>, il linter di Rust. √à consigliatissimo attivare tutti i <em>lint</em> di Clippy fin dal primo giorno<a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=Turn%20on%20all%20clippy%20lints,step%20once%20your%20program%20compiles">[47]</a>. Clippy ti dar√† consigli su come migliorare il codice anche oltre gli errori strettamente necessari: ad esempio ti avvisa di possibili usi subottimali, codice non idiomatico, ecc. √à come avere un reviewer robotico sempre disponibile. Unendo i puntini: <em>compilatore + Clippy + messaggi d&#39;errore dettagliati</em> trasformano quella che poteva essere un&#39;esperienza di apprendimento solitaria in qualcosa di molto pi√π guidato. Certo, rimane <strong>impegnativo</strong> - Rust non ti regala nulla - ma non sei solo: √® come avere un team di mentori virtuali sempre con te (e aggiungiamo la community sui forum/Discord/Stack Overflow, che in Rust √® notoriamente accogliente<a href="https://users.rust-lang.org/t/isnt-rust-too-difficult-to-be-widely-adopted/6173#:~:text=Isn%27t%20rust%20too%20difficult%20to,the%20rough%20spots%20and%20surprises">[48]</a>).</p>
<p>In conclusione, il compilatore di Rust all&#39;inizio pu√≤ sembrare un ostacolo, ma col tempo diventa <em>il tuo migliore amico</em>. Questo cambiamento di prospettiva - da &quot;lo odio&quot; a &quot;mi fido di lui&quot; - √® forse il segnale pi√π evidente che stai facendo tuo il modello mentale di Rust. Quando smetti di vederlo come un freno e inizi a usarlo come <strong>strumento attivo per migliorare il tuo codice</strong>, hai superato un punto di non ritorno: stai ragionando &quot;in Rust&quot;. E come vedremo, a quel punto molte delle difficolt√† percepite svaniscono, lasciando il posto ai reali benefici.</p>
<h2 id="real-difficulties-vs-initial-friction">Real Difficulties vs. Initial Friction</h2>
<p>Ci sono aspetti di Rust che <strong>sono realmente complessi</strong>, e altri che <em>sembrano</em> difficili solo finch√© non si adotta il giusto approccio mentale. √à importante distinguere le due cose. Spesso chi √® all&#39;inizio mette tutto sullo stesso piano (&quot;Rust √® difficile e basta&quot;), ma facendo un passo indietro si pu√≤ chiedere: quali concetti di Rust restano complicati anche dopo averli caputi, e quali invece diventano <strong>non-problemi</strong> una volta che hai fatto &quot;click&quot; col linguaggio?</p>
<p>Difficolt√† <em>reali</em>, o intrinseche, di Rust includono sicuramente alcune sue funzionalit√† avanzate: - <strong>Lifetimes complessi:</strong> il sistema dei lifetime in Rust √® in genere comprensibile nei casi semplici, ma in scenari pi√π avanzati (tipologie di dati auto-referenziali, grafi di oggetti mutualmente dipendenti, ecc.) pu√≤ diventare molto intricato. Anche molti Rustacei esperti talvolta faticano con lifetime particolarmente arzigogolati. Fortunatamente, questi casi non si presentano di frequente nello sviluppo quotidiano <em>se progetti bene le cose</em>: spesso esistono design alternativi per evitare casse di lifetime troppo complicate. Ma va riconosciuto che <em>s√¨, i lifetime sono un concetto difficile</em> da padroneggiare del tutto - anche se, va detto, <strong>nei casi comuni il compilatore li inferisce e non ci si pensa troppo</strong>. Il grosso dell&#39;attrito con i lifetime √® nella fase di apprendimento iniziale (capire cosa sono &#39;a e soci); dopo, compaiono raramente in forma esplicita salvo appunto in codice altamente sofisticato.</p>
<ul>
<li><strong>The concurrency/async model:</strong> Rust offers <em>fearless concurrency</em> at compile-time, but this means that concepts like <em>thread safety</em> and <em>static future lifetimes</em> must be understood for concurrent programming. The use of async/await in Rust, combined with Future, Pin, and the Send requirements for passing tasks to a threadpool, represents a significant increase in complexity compared to asynchronous models in other languages. Someone has called it <em>&quot;a trapdoor underfoot&quot;</em> for those who, after painstakingly learning ownership and traits, try to tackle async<a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=Rust%E2%80%99s%20async%20model%20is%20powerful%2C,and%20pinning">[22]</a>. Suddenly, errors like Send + &#39;static appear, requiring further explanation. This is certainly an area where Rust <strong>is complex</strong> - not so much due to poor design, but because it imposes constraints that other languages delegate to the runtime or ignore. The good news is that in many cases, libraries can be used to simplify the picture somewhat, but it remains an advanced area.</li>
<li><strong>Advanced generics and trait objects:</strong> Using basic generics (parametric functions or structs) is easy, but Rust allows for great power with its trait and generic type system - and with power comes complexity. For example, understanding how to return trait-ified values from functions (using impl Trait or trait objects with Box&lt;dyn Trait&gt;) is not immediate for newcomers, who encounter errors like <em>&quot;the size for values of type T cannot be known at compile time&quot;</em><a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=And%20Rust%20says%3A">[49]</a>. This forces one to learn concepts like monomorphization vs. dynamic dispatch, which, again, are hidden elsewhere. Not only that: combining generics, lifetimes, and traits can lead to long and complicated function signatures. Fortunately, Rust offers alternatives (such as the aforementioned impl Trait and, in the future, probably more ergonomic existential type generics) to simplify many of these uses. However, it remains true that <em>Rust&#39;s type system is rich</em>, and in its more sophisticated corners, it can be arduous.</li>
<li><strong>Metaprogramming and macros:</strong> Rust has a powerful compile-time macro system (macro by example, procedural, etc.). Writing advanced macros can be difficult (although the average user might almost never need to do so). Even understanding macro-generated code is sometimes tricky, because compile-time errors occur in the expanded code, not directly in the macro. However, this difficulty is reserved for those who want to delve into metaprogramming - many can get by using macros written by others, and that&#39;s fine.</li>
<li><strong>Unsafe and low-level code:</strong> if you are writing unsafe code, you are disabling the compiler&#39;s safety checks and taking on enormous responsibilities (manually ensuring memory safety). This <em>is</em> difficult and will remain so, but it is deliberately confined to parts of the code that interact with the system or involve aggressive optimizations. Most Rust code never directly touches unsafe, especially at the beginning.</li>
</ul>
<p>These are the <em>objective</em> complexities of Rust. However, it&#39;s important to note that <strong>most programmers do not need to master these aspects immediately to be productive</strong>. Rust can be used effectively even by staying within the &quot;safe&quot; subset and using relatively simple patterns. One of the often-given pieces of advice is to <em>avoid delving immediately into the more abstruse parts</em>: for example, avoid async in the first week<a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=,learning%20the%20core%20ownership%20model">[50]</a>, don&#39;t start by writing generic macros or complicated type hacks. Learn gradually: many advanced concepts will only be introduced when truly needed. As Julio Merino observes, there are advanced concepts in Rust that require patience, but <strong>are not frequently necessary</strong>; it&#39;s enough to know they exist and where to find information when you need it<a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html#:~:text=Let%E2%80%99s%20conclude%20by%20saying%20that%2C,know%20where%20to%20head%20to">[51]</a>. In short, <em>you can achieve a great deal with Rust without venturing into the darkest corners of the language</em>.</p>
<p>On the other hand, let&#39;s now look at the difficulties that are more like <strong>initial friction</strong>, destined to disappear with time and practice:</p>
<ul>
<li><p><strong>Ownership and borrowing in common cases:</strong> Initially, the idea that a variable &quot;moves&quot; or that an &amp; is needed to pass a reference drives you crazy. But after a few months, it literally becomes <em>part of your way of thinking</em>. Don&#39;t believe it? Ask anyone who uses Rust daily: many report that they now reason in terms of ownership even when writing pseudocode in a document. The concept of who owns what and temporary borrowing becomes natural, and in fact, when they return to writing in languages without these rules, they feel almost &quot;too free&quot; and a bit worried (&quot;uh-oh, I can modify this object from two different places here, let&#39;s hope for the best‚Ä¶&quot;). So, what initially seems like <strong>the</strong> insurmountable mountain (the infamous borrow checker) is actually not a long-term problem. A Hacker News user wrote: <em>&quot;I barely spend any time fighting the borrow checker anymore, like most seasoned Rust programmers. It&#39;s pretty much all gain at this point&quot;</em><a href="https://news.ycombinator.com/item?id=19399532#:~:text=1,It%27s%20a%20different">[52]</a>. This testifies that yes, it&#39;s tough at first, but once the mental &quot;muscle&quot; is softened, you no longer think about it - and you only reap the benefits (no more segfaults, data races, etc.).</p>
</li>
<li><p><strong>Code verbosity/ceremony:</strong> writing Some(x) instead of being able to use null, calling .clone(), doing match result { Ok(v) =&gt; ..., Err(e) =&gt; ... } instead of throwing exceptions - all these things that you initially perceive as annoying, lose weight over time. You become skilled at using idiomatic shortcuts (? for error propagation, methods like .map_err() etc.) and above all <strong>understand the why</strong> behind each one. For example, accepting to &quot;<strong>use clone when needed without shame</strong>&quot; is almost a rite of passage: newcomers do everything to avoid copies because they think it&#39;s &quot;illegal&quot; in Rust, then comes the moment when they realize that explicitly calling clone is okay if needed, and the compiler doesn&#39;t judge you badly for it - it just wants you to be aware of it<a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=ownership%2C%20lifetimes%2C%20and%20traits%20from,the%20start">[53]</a>. After that point, you stop counting how many times you need to clone and simply reason about performance more holistically. The same goes for using types like String vs &amp;str: initially you make mistakes, passing String when &amp;str would be needed and vice versa, and you get angry because &quot;Rust wants a String here, why can&#39;t I pass the literal directly?&quot;. Then little by little you learn when one and the other are needed. In other words: <strong>the friction of new things passes with experience</strong>. A useful tip from the field is: initially, don&#39;t be afraid to write unidiomatic code as long as it works - e.g., feel free to copy with .clone() everywhere, use concrete types instead of generics if it simplifies things, avoid complicating yourself with too many traits - you can always refactor later when you know more<a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=Don%E2%80%99t%20make%20it%20too%20hard,Here%20are%20some%20tips">[54]</a>. Rust, once you have something that compiles, allows you to improve it with great ease (thanks to the compiler protecting you during refactoring, as mentioned). So it&#39;s better to <em>first</em> reach a point where the code works, even if verbose, <em>then</em> refine the style as you understand the best idioms.</p>
</li>
<li><p><strong>Strange syntax and symbols</strong>: remembering to put &amp; before a variable to pass it as a reference, understanding that sequence of -&gt; Result&lt;(), E&gt; in a function signature, deciphering errors with lifetime &amp;&#39;a T: all things that initially seem like hieroglyphs, but by dint of seeing them, they become familiar. It becomes almost muscle memory: you write &amp;mut self in methods without thinking, use ::&lt;&gt; for turbofish when needed, read Box&lt;dyn Trait&gt; as if it were nothing. Here too, many testify that Rust is &quot;full of seals and jargon&quot; but then <em>&quot;you get used to it and it becomes second nature&quot;</em><a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=Yeah%2C%20Rust%20can%20be%20pretty,other%20way%20to%20do%20it">[55]</a>. So syntactic verbosity is only a temporary difficulty - once the acclimatization period is over, you no longer notice the additional symbols, while appreciating what they express.</p>
</li>
<li><p><strong>The &quot;Rust-style&quot; design</strong>: this is the mother of all differences. As long as you try to force Rust to do things &quot;the way you would in X&quot;, Rust will resist (compiler, design, libraries). When you start to <em>think in Rust</em>, however, you find that everything flows much more smoothly. A forum participant describes it well: <em>&quot;it&#39;s really hard at first, but once you know</em> how to think in Rust_, the language becomes productive and enjoyable. All those annotations (*, &amp;&#39;a, Box etc.) have a precise meaning, and allow you to write very fast, multi-threaded programs without fear of NullPointerException&quot;_<a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=Rust%20isn%27t%20too%20bad,threaded%20programs%20without%20%60NullPointerException">[56]</a>. It&#39;s literally a paradigm shift: you stop fighting the language and start <em>working with it</em>. Many call this moment the <strong>&quot;mental click&quot;</strong>.</p>
</li>
</ul>
<p>In summary: Rust has a solid but limited conceptual <em>core</em> (ownership/borrowing, basic lifetimes, traits) that absolutely must be assimilated - and that is the initial hurdle. Beyond this core, it has an ecosystem of advanced features that <em>can</em> be difficult, but are not mandatory for common initial use cases. Once that first steep step is climbed, <strong>the perceived difficulties almost totally disappear</strong>: using Rust becomes smooth and no more strenuous than the average of other languages. Intrinsic complexities remain - but you only encounter those when truly needed, perhaps after having already accumulated experience and thus with the appropriate mental tools to manage them.</p>
<p>An excellent piece of advice found on Reddit states: <em>&quot;Rust is difficult at first because it imposes new constraints on you, constraints that actually existed before but were not checked&quot;</em>. Here&#39;s the point: Rust materializes obstacles that in other languages remain invisible until you stumble upon them (think memory management, concurrency, errors). So yes, <strong>it&#39;s harder at first</strong>, because <em>you are explicitly overcoming obstacles that were implicit elsewhere</em>. But once past the beginning, it&#39;s not that Rust &quot;continues to be increasingly difficult&quot; - on the contrary, often those who learn Rust notice that after a while they can focus on the application&#39;s logic <em>more freely</em> than before, because many concerns (null, race conditions, memory leaks) have been handled by the language.</p>
<h2 id="the-mental-click-and-long-term-benefits">The &quot;Mental Click&quot; and Long-Term Benefits</h2>
<p>Almost every Rust developer can tell of <strong>a turning point</strong> during their learning: an instant when everything became clearer, a <em>click</em> indeed. After weeks (or months) of frustration, the day comes when you write a piece of code and... it compiles on the first try, or the day when reading an error message you think &quot;Oh right, I forgot to put <code>mut</code>, how did I not notice that immediately?&quot;. In short, the day you stop feeling constantly hindered and start collaborating with Rust. For some, it&#39;s truly an almost mystical moment; more often it&#39;s gradual progress, but in hindsight, you identify a period when your productivity with Rust took off.</p>
<p>What exactly happens in this &quot;click&quot;? In simple terms, <strong>you stop fighting Rust and start working with Rust</strong>. One author describes it this way: <em>&quot;I stopped trying to outsmart the compiler. I started listening to it&quot;</em><a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=I%20stopped%20trying%20to%20outsmart,I%20started%20listening%20to%20it">[57]</a>. Instead of treating Rust as a language where you force your usual patterns, you have accepted to <strong>design the program around ownership, lifetimes, and traits from the start</strong><a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=I%20stopped%20trying%20to%20outsmart,I%20started%20listening%20to%20it">[57]</a>. This might involve changing how you write functions, thinking first about who will own the data, choosing to return a Result instead of throwing exceptions, using Option types instead of avoiding the problem, and so on<a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=Rust%20isn%E2%80%99t%20just%20a%20language,and%20traits%20from%20the%20start">[58]</a>. It also means <em>&quot;accepting <code>clone</code>&quot;</em> when needed<a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=ownership%2C%20lifetimes%2C%20and%20traits%20from,the%20start">[59]</a>, meaning not stubbornly insisting on avoiding copies at all costs if the cost in mental complexity is worse than the cost in performance. In practice, <strong>you start writing code the way Rust expects</strong>, and almost miraculously the compiler starts &quot;complaining&quot; much less.</p>
<p>Warning: it&#39;s not that Rust suddenly became easy - it&#39;s that you stopped using wrong approaches<a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=And%20slowly%2C%20Rust%20began%20to,fight%20me%20less">[60]</a>. As that article wisely notes, <em>Rust stopped fighting me not because it became easier, but because I stopped writing code the wrong way</em><a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=And%20slowly%2C%20Rust%20began%20to,fight%20me%20less">[61]</a>. It&#39;s a powerful mindset shift: you realize that often, if the compiler complained, it was because your design actually had a problem (perhaps not immediately obvious to you, but real). When you start to internalize the &quot;Rust way of thinking,&quot; you prevent certain errors upstream yourself, and thus the compiler runs smoothly.</p>
<p>In parallel with this mental click, the <strong>medium-to-long-term benefits</strong> of Rust begin to fully emerge. Benefits you might have heard about in theory, but it&#39;s different to <em>experience them</em> firsthand:</p>
<ul>
<li><p><strong>&quot;If it compiles, it probably works.&quot;</strong> This phrase is almost a mantra in Rust. Of course, it&#39;s not an absolute truth (logical bugs can always exist), but those coming from languages like C++ or Java are often surprised by the confidence Rust offers: when you finally manage to compile a complex program, there&#39;s a high probability it will run correctly on the first try<a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=Once%20you%20get%20over%20the,crashes%2C%20no%20silent%20data%20corruption">[62]</a><a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=The%20compiler%20is%20great%20at,you%20get%20used%20to%20it">[44]</a>. You will almost never see unexpected crashes, <em>segmentation faults</em>, <em>null pointer exceptions</em>, or multithreaded data races when running <em>safe</em> Rust programs<a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=Once%20you%20get%20over%20the,crashes%2C%20no%20silent%20data%20corruption">[62]</a>. This gives you a peace of mind that revolutionizes your development process. You can make even deep changes to the code and trust that if something goes wrong, the compiler will tell you immediately. One user recounted: &quot;once my Rust code compiled, it was of immensely higher quality than the Java code I had been writing for years&quot;<a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=I%20come%20from%20Java%20too,been%20writing%20professionally%20for%20years">[63]</a>. It sounds exaggerated, but that user emphasizes how the Rust programs they write now positively surprise them compared to similar Java programs written in the past, precisely because of the absence of certain defects<a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=I%20come%20from%20Java%20too,been%20writing%20professionally%20for%20years">[63]</a>.</p>
</li>
<li><p><strong>Fewer bugs and less debugging.</strong> Consequence of the previous point: many categories of bugs simply <em>no longer happen</em>. Use-after-free? Impossible in safe Rust. Concurrency with race conditions? The compiler won&#39;t let you share mutable data without adequate protections. Null dereference? Rust doesn&#39;t have null (except in unsafe code), you use Option and therefore <em>must</em> handle the absence of a value. Arithmetic overflow? Rust, in debug mode, detects them at runtime (in release mode, it handles them with wrapping, but you can enable checks if you want). And so on. Even logical errors - like forgetting to handle an error case - become less frequent because Rust pushes you to consider all of them. The practical result is that once you overcome the initial struggle, you will <strong>spend less time hunting for bugs</strong>. This is confirmed by many developers: Rust drastically reduces the time spent on troubleshooting compared to C/C++, for example, because if the program compiles, you already have the certainty that many possible problems are not present<a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=Once%20you%20get%20over%20the,crashes%2C%20no%20silent%20data%20corruption">[62]</a>. There can, of course, be application bugs (a wrong calculation, an unhandled condition that is &quot;logically&quot; valid for the compiler), but those can be covered with tests - and in the meantime, you haven&#39;t had to worry about the usual memory or concurrency issues that plague other ecosystems.</p>
</li>
<li><p><strong>Easier Refactoring and Maintenance.</strong> We&#39;ve said that Rust forces you to fix everything before it compiles. What initially is an annoyance (&quot;nothing compiles until everything is correct!&quot;) over time becomes a superpower. You realize you can <em>dare</em> to undertake very large refactorings ‚Äì changing module structure, modifying return types of public functions, reorganizing ownership between components ‚Äì with the infallible help of the compiler. In other environments, refactoring can be risky: you might forget to update a point and introduce a bug that you&#39;ll perhaps discover in production. In Rust, as long as the code compiles, you have high confidence that you&#39;ve correctly applied every necessary change<a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=,dismiss%20the%20language%20right%20away">[29]</a>. This certainty encourages writing cleaner code: if you know you can easily restructure it, you won&#39;t hesitate to improve it. In languages where refactoring is burdensome or risky, people often prefer to keep suboptimal code to avoid breaking anything. With Rust, it&#39;s easier to maintain a healthy codebase and adapt it to new requirements.</p>
</li>
<li><p><strong>Predictable Performance and Fewer &quot;Black Magic&quot;.</strong> Rust, being free of a heavy runtime, gives you performance close to C/C++, but above all, <strong>predictable</strong> performance. No garbage collector starting in the middle of a critical transaction causing a glitch; no VM optimizing code in inscrutable ways (ok, LLVM is behind the scenes, but in general you have more control over allocations and behavior). This means that investing in Rust pays off especially in scenarios where performance and control are crucial (systems, embedded, high-intensity server applications, etc.). Many adopt Rust precisely for this reason: after the initial curve, you have a tool that allows you to build software with system performance <strong>without having to descend to unsafe C level</strong>. And with the added confidence that if your Rust program compiles without <em>unsafe</em>, you can practically <em>forget</em> about all the manual memory problems that make C/C++ development a nightmare. It&#39;s a level of <strong>trust</strong> rarely achievable elsewhere. It&#39;s no coincidence that the Rust team&#39;s motto is <em>&quot;fearless&quot;</em>: <em>fearless concurrency, fearless refactoring, fearless future</em>. It means being able to tackle difficult problems (like concurrency) without the fear of introducing invisible bugs, because you know the compiler <em>has your back</em>.</p>
</li>
<li><p><strong>Growth as a Programmer.</strong> Many report that learning Rust has made them better programmers even when they return to other languages<a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=Rust%20made%20me%20a%20better,way%20I%20never%20had%20before">[64]</a><a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=The%20result%20is%20really%20worth,it%20from%20the%20very%20beginning">[23]</a>. Why? Because Rust forces you to think about aspects you previously ignored. After using Rust, when allocating objects in a tight loop in Java, you might start to question the garbage collector, something you previously did distractedly. Or you pay more attention to avoiding global mutable states in Python because you&#39;ve seen the benefits of default immutability. In short, Rust <strong>trains good habits</strong> that are transferable. One developer wrote: <em>&quot;Rust forced me to think about ownership, lifetimes, and correctness in a way I never had before, and this has made me a better programmer in every language&quot;</em><a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=Rust%20made%20me%20a%20better,way%20I%20never%20had%20before">[64]</a>. It&#39;s a great compliment to the language: not only was it not impossible to learn, but that effort even elevated their overall skill level.</p>
</li>
</ul>
<p>All this leads to the final answer: <em>why Rust isn&#39;t really difficult</em>. The difficulty we perceive is the initial toll to enter a new way of programming. Once that toll is paid, the road smooths out and <strong>the journey proceeds swiftly</strong>. At that point, Rust is no more difficult than any other language ‚Äì in fact, in some ways it becomes easier, because you have tools that constantly monitor and help you. As one user said: &quot;Rust isn&#39;t so terrible after all. Once you&#39;ve learned what there is to learn, it&#39;s actually a path to a new world, not a nightmare&quot;<a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=you%20face%20it%20from%20the,very%20beginning">[65]</a>. And there&#39;s an entire community of people ready to confirm it and help you along the way<a href="https://users.rust-lang.org/t/isnt-rust-too-difficult-to-be-widely-adopted/6173#:~:text=Isn%27t%20rust%20too%20difficult%20to,the%20rough%20spots%20and%20surprises">[48]</a>.</p>
<p>Per concludere con una metafora, usare Rust √® un po&#39; come un <strong>addestramento intensivo</strong>. All&#39;inizio ti sembra di subire un trattamento da &quot;Full Metal Jacket&quot; - ti urla contro, ti fa rifare il letto 10 volte, non capisci perch√© tutta questa disciplina. Ma alla fine del campionato, sei temprato, forte e preparato a situazioni che altri non reggerebbero. Rust alla fine <strong>&quot;si fida di te perch√© ti ha addestrato a meritartelo&quot;</strong><a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=But%20if%20you%20can%20survive,other%20side%20with%20something%20rare"><strong><em>[66]</em></strong></a><strong><em>: dopo averti messo alla prova e insegnato la disciplina, il linguaggio ti concede di fare cose potenti (sistemi concorrenti ad alte prestazioni, ad esempio) con la sicurezza che non ti sparerai sui piedi. E quando ti troverai davanti a un errore compilatore apparentemente indecifrabile e scoraggiante, ricorda le parole di chi c&#39;√® passato:</em> non sei solo*. Tutti abbiamo avuto quel momento di sconforto, ma</strong> perseverando si supera**<a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=And%20when%20you%20find%20yourself,makes%20no%20sense%2C%20remember%20this">[67]</a>. Il gioco vale la candela: Rust ti ripagher√† con un&#39;esperienza di programmazione appagante, in cui tornerai a divertirti a scrivere codice sapendo che quello che scrivi √® robusto e &quot;corretto per costruzione&quot;.</p>
<p>In definitiva, Rust <em>sembra</em> difficile all&#39;inizio perch√© ti chiede di cambiare mentalit√† - ma <strong>non lo √® in senso assoluto</strong>. √à diverso, √® rigoroso, ma non √® stregoneria. Come ogni cosa nuova e valida, richiede impegno per essere padroneggiata. E una volta padroneggiata, scoprirai forse di aver trovato non solo un linguaggio efficiente, ma anche un <em>mentore</em> che ti ha insegnato a programmare in modo pi√π consapevole. Quindi, armati di pazienza, abbraccia il cambiamento di paradigma, e continua a provarci: <em>keep going. It gets better</em><a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=And%20when%20you%20find%20yourself,makes%20no%20sense%2C%20remember%20this">[67]</a>.</p>
<p><strong>Fonti:</strong> Rust Forum, Medium, Blog tecnici e documentazione ufficiale citati nel testo<a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=Learning%20Rust%20can%20feel%20like,intellectual%20hazing">[2]</a><a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html#:~:text=Let%E2%80%99s%20now%20take%20a%20different,1">[9]</a><a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=As%20a%20Java%20developer%20playing,would%20have%20written%20with%20Java">[24]</a><a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=Treat%20the%20borrow%20checker%20as,couldn%E2%80%99t%20figure%20it%20out%20itself">[42]</a>, etc.</p>
<p><a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=each%20other">[1]</a> <a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=Learning%20Rust%20can%20feel%20like,intellectual%20hazing">[2]</a> <a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=The%20borrow%20checker%20will%20make,don%E2%80%99t%20know%20how%20to%20code">[3]</a> <a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=There%E2%80%99s%20a%20reason%20developers%20love,documented">[4]</a> <a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=let%20s%20%3D%20String%3A%3Afrom%28,now%20s%20is%20invalid">[16]</a> <a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here%E2%80%99s-how-i-survived-459082669e91#:~:text=What%20just%20happened%3F%20You%20didn%E2%80%99t,can%20only%20be%20touched%20once">[17]</a> <a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=Rust%E2%80%99s%20async%20model%20is%20powerful%2C,and%20pinning">[22]</a> <a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=You%20start%20second">[36]</a> <a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=The%20borrow%20checker%20will%20make,don%E2%80%99t%20know%20how%20to%20code">[37]</a> <a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=Here%E2%80%99s%20what%20finally%20made%20the,difference">[40]</a> <a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=And%20Rust%20says%3A">[49]</a> <a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=ownership%2C%20lifetimes%2C%20and%20traits%20from,the%20start">[53]</a> <a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=I%20stopped%20trying%20to%20outsmart,I%20started%20listening%20to%20it">[57]</a> <a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=Rust%20isn%E2%80%99t%20just%20a%20language,and%20traits%20from%20the%20start">[58]</a> <a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=ownership%2C%20lifetimes%2C%20and%20traits%20from,the%20start">[59]</a> <a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=And%20slowly%2C%20Rust%20began%20to,fight%20me%20less">[60]</a> <a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=And%20slowly%2C%20Rust%20began%20to,fight%20me%20less">[61]</a> <a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=Once%20you%20get%20over%20the,crashes%2C%20no%20silent%20data%20corruption">[62]</a> <a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=Rust%20made%20me%20a%20better,way%20I%20never%20had%20before">[64]</a> <a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=But%20if%20you%20can%20survive,other%20side%20with%20something%20rare">[66]</a> <a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91#:~:text=And%20when%20you%20find%20yourself,makes%20no%20sense%2C%20remember%20this">[67]</a> Rust&#39;s Learning Curve Is Brutal - Here&#39;s How I Survived | by Tech In Focus | Medium</p>
<p><a href="https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91">https://medium.com/@techInFocus/rusts-learning-curve-is-brutal-here-s-how-i-survived-459082669e91</a></p>
<p><a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html#:~:text=Let%E2%80%99s%20first%20start%20by%20stating,not%20months%2C%20of%20frequent%20practice">[5]</a> <a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html#:~:text=learning%20its%20syntax,not%20months%2C%20of%20frequent%20practice">[6]</a> <a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html#:~:text=When%20seen%20through%20these%20lenses%2C,days%20of%20learning%20are%20amortized">[7]</a> <a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html#:~:text=The%20problem%20is%20that%20simpler,can%20be%20deployed%20or%20released">[8]</a> <a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html#:~:text=Let%E2%80%99s%20now%20take%20a%20different,1">[9]</a> <a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html#:~:text=memory%20allocation%20and%20concurrency,1">[10]</a> <a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html#:~:text=Rust%20falls%20in%20the%20more,computer%E2%80%99s%20processor%20and%20memory%20model">[11]</a> <a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html#:~:text=My%20take%20on%20this%3A%20for,in%20a%20more%20troublesome%20spot">[12]</a> <a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html#:~:text=The%20good%20thing%20is%20that,language%20you%20write%20code%20in">[13]</a> <a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html#:~:text=Let%E2%80%99s%20conclude%20by%20saying%20that%2C,know%20where%20to%20head%20to">[51]</a> Rust review: Learning curve - Julio Merino (jmmv.dev)</p>
<p><a href="https://jmmv.dev/2018/06/rust-review-learning-curve.html">https://jmmv.dev/2018/06/rust-review-learning-curve.html</a></p>
<p><a href="https://mmapped.blog/posts/15-when-rust-hurts#:~:text=,Bjarne%20Stroustrup">[14]</a> <a href="https://mmapped.blog/posts/15-when-rust-hurts#:~:text=Yet%2C%20I%20often%20find%20myself,is%20perfect%20for%20every%20problem">[15]</a> <a href="https://mmapped.blog/posts/15-when-rust-hurts#:~:text=However%2C%20our%20first%20naive%20version,write%20the%20following%20expression%20instead">[34]</a> <a href="https://mmapped.blog/posts/15-when-rust-hurts#:~:text=let%20s%20%3D%20,to_string%28%29%3B%20f%28s.clone%28%29%29%3B%20g%28s">[35]</a> When Rust hurts</p>
<p><a href="https://mmapped.blog/posts/15-when-rust-hurts">https://mmapped.blog/posts/15-when-rust-hurts</a></p>
<p><a href="https://medium.com/rustaceans/rust-errors-arent-exceptions-87ce365d4dff#:~:text=Only%20panic%20when%20necessary">[18]</a> Rust Errors Aren&#39;t Exceptions. Even if they look a lot alike | by Enzo Lombardi | Rustaceans | Dec, 2025 | Medium</p>
<p><a href="https://medium.com/rustaceans/rust-errors-arent-exceptions-87ce365d4dff">https://medium.com/rustaceans/rust-errors-arent-exceptions-87ce365d4dff</a></p>
<p><a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=Rust%20isn%27t%20object,are%20not%20natural%20in%20Rust">[19]</a> <a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming%20from%20java/37650#:~:text=I%20am%20an%20engineer%2C%20yes,language%20is%20JavaScript%20or%20Python">[20]</a> <a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=">[21]</a> <a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=The%20result%20is%20really%20worth,it%20from%20the%20very%20beginning">[23]</a> <a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=As%20a%20Java%20developer%20playing,would%20have%20written%20with%20Java">[24]</a> <a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=My%20first%20step%20was%20reading,be%20thankful%20for%20every%20error">[43]</a> <a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=The%20compiler%20is%20great%20at,you%20get%20used%20to%20it">[44]</a> <a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=Yeah%2C%20Rust%20can%20be%20pretty,other%20way%20to%20do%20it">[55]</a> <a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=Rust%20isn%27t%20too%20bad,threaded%20programs%20without%20%60NullPointerException">[56]</a> <a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650#:~:text=I%20come%20from%20Java%20too,been%20writing%20professionally%20for%20years">[63]</a> <a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to%20learn-coming-from-java/37650#:~:text=you%20face%20it%20from%20the,very%20beginning">[65]</a> Rust is a nightmare to learn coming from Java - community - The Rust Programming Language Forum</p>
<p><a href="https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650">https://users.rust-lang.org/t/rust-is-a-nightmare-to-learn-coming-from-java/37650</a></p>
<p><a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=Your%20learning%20pace%20doesn%E2%80%99t%20have,your%20attitude%20toward%20the%20language">[25]</a> <a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=I%20have%20seen%20junior%20devs,Leave%20your%20hubris%20at%20home">[26]</a> <a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=If%20you%20come%20from%20a,scale%20applications">[27]</a> <a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=,because%20the%20compiler%20can%20check">[28]</a> <a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=,dismiss%20the%20language%20right%20away">[29]</a> <a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=If%20you%20try%20to%20compile,It%20provides%20this%20helpful%20suggestion">[30]</a> <a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=So%20you%20don%E2%80%99t%20have%20to,couldn%E2%80%99t%20figure%20it%20out%20itself">[31]</a> <a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=,%E2%80%93%20An%20ancient%20Rust%20proverb">[32]</a> <a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=You%20can%20be%20sloppy%20in,debugging%20time%20in%20the%20future">[33]</a> <a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=Treat%20the%20borrow%20checker%20as,couldn%E2%80%99t%20figure%20it%20out%20itself">[41]</a> <a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=Treat%20the%20borrow%20checker%20as,couldn%E2%80%99t%20figure%20it%20out%20itself">[42]</a> <a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=Most%20of%20the%20time%20when,do%20it%20the%20Rust%20way">[46]</a> <a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=Turn%20on%20all%20clippy%20lints,step%20once%20your%20program%20compiles">[47]</a> <a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=,learning%20the%20core%20ownership%20model">[50]</a> <a href="https://corrode.dev/blog/flattening-rusts-learning-curve/#:~:text=Don%E2%80%99t%20make%20it%20too%20hard,Here%20are%20some%20tips">[54]</a> Flattening Rust&#39;s Learning Curve | corrode Rust Consulting</p>
<p><a href="https://corrode.dev/blog/flattening-rusts-learning-curve/">https://corrode.dev/blog/flattening-rusts-learning-curve/</a></p>
<p><a href="https://ferrous-systems.com/blog/the-compiler-is-your-friend/#:~:text=error,cannot%20borrow%20as%20mutable">[38]</a> <a href="https://ferrous-systems.com/blog/the-compiler-is-your-friend/#:~:text=The%20compiler%20gives%20us%20an,the%20affected%20variable%20is%20underlined">[39]</a> Learning Rust: The Compiler is your Friend - Ferrous Systems</p>
<p><a href="https://ferrous-systems.com/blog/the-compiler-is-your-friend/">https://ferrous-systems.com/blog/the-compiler-is-your-friend/</a></p>
<p><a href="https://news.ycombinator.com/item?id=44005195#:~:text=Evolution%20of%20Rust%20Compiler%20Errors,explanation%20of%20why%20it%27s%20wrong">[45]</a> Evolution of Rust Compiler Errors | Hacker News</p>
<p><a href="https://news.ycombinator.com/item?id=44005195">https://news.ycombinator.com/item?id=44005195</a></p>
<p><a href="https://users.rust-lang.org/t/isnt-rust-too-difficult-to-be-widely-adopted/6173#:~:text=Isn%27t%20rust%20too%20difficult%20to,the%20rough%20spots%20and%20surprises">[48]</a> Isn&#39;t rust too difficult to be widely adopted?</p>
<p><a href="https://users.rust-lang.org/t/isnt-rust%20too%20difficult%20to%20be%20widely%20adopted/6173">https://users.rust-lang.org/t/isnt-rust%20too%20difficult%20to%20be%20widely%20adopted/6173</a></p>
<p><a href="https://news.ycombinator.com/item?id=19399532#:~:text=1,It%27s%20a%20different">[52]</a> 1. You still have to fight with borrow checking in Rus... - Hacker News</p>
<p><a href="https://news.ycombinator.com/item?id=19399532">https://news.ycombinator.com/item?id=19399532</a></p>
        </div>
      </section>
    </article>
  </main>
  <footer>
    <span data-it="¬© 2025 Mirko Calcaterra. Tutti i diritti riservati."
          data-en="¬© 2025 Mirko Calcaterra. All rights reserved.">
      ¬© 2025 Mirko Calcaterra. Tutti i diritti riservati.
    </span>
  </footer>
  <script>
    const BLOG_LANG_KEY = 'blogLang';
    const BLOG_THEME_KEY = 'blogTheme';
    const CURRENT_LANG = "en";
    const OTHER_LANG = "it";
    const OTHER_LANG_LINK = "../../../blog/it/perche-rust/index.html";
    (function() {
      const body = document.body;
      const themeToggle = document.querySelector('.theme-toggle');
      const themeThumb = document.querySelector('.theme-toggle .theme-thumb');
      const langBtn = document.querySelector('.lang-btn');
      const tocElement = document.querySelector('.post-toc');
      const tocToggle = tocElement ? tocElement.querySelector('.post-toc__toggle') : null;
      const tocToggleText = tocElement ? tocElement.querySelector('.post-toc__toggle-text') : null;
      const tocTitle = tocElement ? tocElement.querySelector('.post-toc__title') : null;
      const tocLinks = tocElement ? Array.from(tocElement.querySelectorAll('.post-toc__link')) : [];
      const headingEntries = tocLinks
        .map((link) => {
          const id = link.getAttribute('href').slice(1);
          const target = document.getElementById(id);
          return target ? { link, target } : null;
        })
        .filter(Boolean);
      const tocLabels = CURRENT_LANG === 'it'
        ? { title: 'Indice', show: 'Mostra indice', hide: 'Nascondi indice' }
        : { title: 'Table of contents', show: 'Show table of contents', hide: 'Hide table of contents' };
      const tableWrappers = Array.from(document.querySelectorAll('.table-wrapper[data-enhanced-table]'));
      const tableLabels = CURRENT_LANG === 'it'
        ? { expand: 'Apri a schermo intero', close: 'Chiudi' }
        : { expand: 'Open full view', close: 'Close' };
      const codeBlocks = Array.from(document.querySelectorAll('.post-body pre'));
      const codeCopyLabels = {
        it: { copy: 'Copia', copied: 'Copiato!' },
        en: { copy: 'Copy', copied: 'Copied!' },
      };
      let tableOverlay = null;
      let tableOverlayScroll = null;
      let tableOverlayClose = null;
      if (tocTitle) {
        tocTitle.textContent = tocLabels.title;
      }
      if (tocToggleText) {
        tocToggleText.textContent = tocLabels.title;
      }
      let tocCollapsed = false;
      let tocManualOverride = false;
      const tocMediaQuery = window.matchMedia ? window.matchMedia('(max-width: 1024px)') : null;
      function ensureTableOverlay() {
        if (tableOverlay) {
          return;
        }
        tableOverlay = document.createElement('div');
        tableOverlay.className = 'table-overlay';
        tableOverlay.innerHTML =
          '<div class="table-overlay__content">' +
          '<button type="button" class="table-overlay__close">' + tableLabels.close + '</button>' +
          '<div class="table-overlay__scroll"></div>' +
          '</div>';
        body.appendChild(tableOverlay);
        tableOverlayScroll = tableOverlay.querySelector('.table-overlay__scroll');
        tableOverlayClose = tableOverlay.querySelector('.table-overlay__close');
        if (tableOverlayClose) {
          tableOverlayClose.setAttribute('aria-label', tableLabels.close);
          tableOverlayClose.addEventListener('click', closeTableOverlay);
        }
        tableOverlay.addEventListener('click', (event) => {
          if (event.target === tableOverlay) {
            closeTableOverlay();
          }
        });
      }
      function closeTableOverlay() {
        if (!tableOverlay) {
          return;
        }
        tableOverlay.classList.remove('table-overlay--visible');
        body.classList.remove('no-scroll');
        if (tableOverlayScroll) {
          tableOverlayScroll.innerHTML = '';
        }
      }
      function openTableOverlay(wrapper) {
        ensureTableOverlay();
        if (!tableOverlay || !tableOverlayScroll) {
          return;
        }
        tableOverlayScroll.innerHTML = '';
        const table = wrapper.querySelector('table');
        if (table) {
          const clone = table.cloneNode(true);
          const tableSize = table.dataset.tableSize;
          if (tableSize) {
            clone.dataset.tableSize = tableSize;
          }
          tableOverlayScroll.appendChild(clone);
        }
        tableOverlay.classList.add('table-overlay--visible');
        body.classList.add('no-scroll');
        if (tableOverlayClose) {
          tableOverlayClose.focus();
        }
      }
      function enhanceTables() {
        if (!tableWrappers.length) {
          return;
        }
        tableWrappers.forEach((wrapper) => {
          if (wrapper.dataset.enhanced === 'true') {
            return;
          }
          const table = wrapper.querySelector('table');
          if (!table) {
            return;
          }
          const headerCells = table.querySelectorAll('thead th');
          const referenceCells = headerCells.length ? headerCells : table.querySelectorAll('tr:first-child > *');
          const columnCount = referenceCells.length;
          let tableSize = '';
          if (columnCount >= 6) {
            tableSize = 'wide';
          } else if (columnCount >= 4) {
            tableSize = 'medium';
          }
          if (tableSize) {
            wrapper.setAttribute('data-table-size', tableSize);
            table.dataset.tableSize = tableSize;
          }
          const expandBtn = document.createElement('button');
          expandBtn.type = 'button';
          expandBtn.className = 'table-wrapper__expand';
          expandBtn.innerHTML = '<span aria-hidden="true">üîç</span> ' + tableLabels.expand;
          expandBtn.setAttribute('aria-label', tableLabels.expand);
          expandBtn.addEventListener('click', () => openTableOverlay(wrapper));
          wrapper.appendChild(expandBtn);
          wrapper.dataset.enhanced = 'true';
        });
      }
      function fallbackCopy(text) {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.setAttribute('readonly', '');
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        textarea.style.left = '-9999px';
        document.body.appendChild(textarea);
        textarea.select();
        let successful = false;
        try {
          successful = document.execCommand('copy');
        } catch (error) {
          successful = false;
        }
        textarea.remove();
        return successful;
      }
      function showCopyFeedback(button, labels) {
        if (button._copyTimeout) {
          clearTimeout(button._copyTimeout);
        }
        const labelEl = button.querySelector('.code-copy-btn__text');
        button.classList.add('code-copy-btn--copied');
        if (labelEl) {
          labelEl.textContent = labels.copied;
        }
        button._copyTimeout = window.setTimeout(() => {
          button.classList.remove('code-copy-btn--copied');
          if (labelEl) {
            labelEl.textContent = labels.copy;
          }
        }, 2000);
      }
      function enhanceCodeBlocks() {
        if (!codeBlocks.length) {
          return;
        }
        const labels = codeCopyLabels[CURRENT_LANG] || codeCopyLabels.en;
        codeBlocks.forEach((pre) => {
          if (pre.dataset.copyEnhanced === 'true') {
            return;
          }
          const code = pre.querySelector('code');
          if (!code) {
            return;
          }
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'code-copy-btn';
          button.setAttribute('aria-label', labels.copy);
          button.innerHTML =
            '<span class="code-copy-btn__icon" aria-hidden="true">üìã</span>' +
            '<span class="code-copy-btn__text">' + labels.copy + '</span>';
          button.addEventListener('click', async () => {
            const text = (code.textContent || '').replace(/s+$/, '');
            if (!text) {
              return;
            }
            let copied = false;
            if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
              try {
                await navigator.clipboard.writeText(text);
                copied = true;
              } catch (error) {
                copied = false;
              }
            }
            if (!copied) {
              copied = fallbackCopy(text);
            }
            if (copied) {
              showCopyFeedback(button, labels);
            }
          });
          pre.appendChild(button);
          pre.dataset.copyEnhanced = 'true';
        });
      }
      function setTocCollapsed(collapsed, { manual = false } = {}) {
        if (!tocElement) {
          return;
        }
        tocCollapsed = Boolean(collapsed);
        if (manual) {
          tocManualOverride = true;
        }
        tocElement.classList.toggle('post-toc--collapsed', tocCollapsed);
        tocElement.setAttribute('data-collapsed', tocCollapsed ? 'true' : 'false');
        if (tocToggle) {
          tocToggle.setAttribute('aria-expanded', tocCollapsed ? 'false' : 'true');
          tocToggle.setAttribute('aria-label', tocCollapsed ? tocLabels.show : tocLabels.hide);
        }
      }
      function initToc() {
        if (!tocElement) {
          return;
        }
        if (tocToggle) {
          tocToggle.addEventListener('click', () => {
            setTocCollapsed(!tocCollapsed, { manual: true });
          });
        }
        if (tocMediaQuery) {
          const handleMediaChange = (event) => {
            if (tocManualOverride) {
              return;
            }
            setTocCollapsed(event.matches);
          };
          if (typeof tocMediaQuery.addEventListener === 'function') {
            tocMediaQuery.addEventListener('change', handleMediaChange);
          } else if (typeof tocMediaQuery.addListener === 'function') {
            tocMediaQuery.addListener(handleMediaChange);
          }
          setTocCollapsed(tocMediaQuery.matches);
        } else {
          setTocCollapsed(false);
        }
      }
      const storedTheme = (localStorage.getItem(BLOG_THEME_KEY) || '').toLowerCase();
      const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      const initialTheme = storedTheme === 'light' ? 'light' : (storedTheme === 'dark' ? 'dark' : (prefersDark ? 'dark' : 'light'));
      let activeLink = null;
      let ticking = false;
      function applyTheme(theme) {
        const resolved = theme === 'dark' ? 'dark' : 'light';
        body.setAttribute('data-theme', resolved);
        if (themeToggle) {
          themeToggle.classList.toggle('active', resolved === 'dark');
        }
        if (themeThumb) {
          themeThumb.textContent = resolved === 'dark' ? 'üåô' : '‚òÄÔ∏è';
        }
        localStorage.setItem(BLOG_THEME_KEY, resolved);
      }
      function setActive(link) {
        if (activeLink === link) {
          return;
        }
        if (activeLink) {
          activeLink.classList.remove('post-toc__link--active');
        }
        if (link) {
          link.classList.add('post-toc__link--active');
        }
        activeLink = link;
      }
      function updateActiveHeading() {
        if (!headingEntries.length) {
          return;
        }
        const scrollPosition = window.scrollY + 160;
        let current = headingEntries[0];
        for (const item of headingEntries) {
          if (item.target.offsetTop <= scrollPosition) {
            current = item;
          } else {
            break;
          }
        }
        setActive(current.link);
      }
      function onScroll() {
        if (ticking) {
          return;
        }
        ticking = true;
        window.requestAnimationFrame(() => {
          updateActiveHeading();
          ticking = false;
        });
      }
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          closeTableOverlay();
        }
      });
      enhanceTables();
      enhanceCodeBlocks();
      initToc();
      applyTheme(initialTheme);
      if (themeToggle) {
        themeToggle.addEventListener('click', () => {
          applyTheme(body.getAttribute('data-theme') === 'dark' ? 'light' : 'dark');
        });
      }
      if (langBtn) {
        langBtn.textContent = CURRENT_LANG === 'it' ? 'EN' : 'IT';
        if (OTHER_LANG_LINK) {
          langBtn.addEventListener('click', () => {
            localStorage.setItem(BLOG_LANG_KEY, OTHER_LANG);
            window.location.href = OTHER_LANG_LINK;
          });
        } else {
          langBtn.disabled = true;
          langBtn.classList.add('lang-btn--disabled');
        }
      }
      localStorage.setItem(BLOG_LANG_KEY, CURRENT_LANG);
      if (headingEntries.length) {
        headingEntries.sort((a, b) => a.target.offsetTop - b.target.offsetTop);
        updateActiveHeading();
        window.addEventListener('scroll', onScroll, { passive: true });
      }
    })();
  </script>
</body>
</html>