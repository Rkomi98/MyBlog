<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Inside a Container: Key Concepts</title>
  <style>
    
  :root {
    color-scheme: light dark;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    line-height: 1.6;
  }
  body {
    margin: 0;
    padding: 0;
    background: var(--bg, #0f172a);
    color: #0f172a;
  }
  @media (prefers-color-scheme: dark) {
    body {
      color: #e2e8f0;
    }
  }
  .page {
    max-width: 960px;
    margin: 0 auto;
    padding: 3rem 1.5rem 4rem;
  }
  header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 2.5rem;
  }
  header nav a {
    margin-left: 1rem;
    text-decoration: none;
    font-weight: 500;
    color: inherit;
  }
  header nav a:hover {
    text-decoration: underline;
  }

    h1 {
      font-size: clamp(2.2rem, 4vw, 3.2rem);
      margin-bottom: 1rem;
    }
    .meta {
      color: #64748b;
      margin-bottom: 2.5rem;
    }
    article {
      font-size: 1.05rem;
    }
    article img {
      max-width: 100%;
      border-radius: 0.75rem;
      margin: 1.5rem 0;
      box-shadow: 0 10px 25px -12px rgba(15, 23, 42, 0.35);
    }
    article pre {
      background: rgba(15, 23, 42, 0.85);
      color: #e2e8f0;
      padding: 1rem 1.25rem;
      overflow-x: auto;
      border-radius: 0.75rem;
    }
    nav {
      margin-bottom: 2rem;
      display: flex;
      gap: 1rem;
    }
    nav a {
      text-decoration: none;
      font-weight: 500;
      color: inherit;
    }
    nav a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <div class="page">
    <nav>
      <a href="../../../blog/index.html">← Blog</a>
      <a href="../../../index.html">Home</a>
      <a href="../../../blog/it/deep-dive-in-docker/">Leggi in Italiano</a>
    </nav>
    <article>
      <header>
        <h1>Inside a Container: Key Concepts</h1>
        <p class="meta">
          Aggiornato il 2025-10-31
        </p>
      </header>
      <h1>Inside a Container: Key Concepts</h1>
<h2>Abstract</h2>
<p>Second episode of the “Docker for Developers” series. This narrative guide walks through Docker’s core ideas with production-grade precision while staying approachable: the goal is to understand what Docker does conceptually before touching the CLI or writing manifests.</p>
<h2>1. Core Concepts</h2>
<p><em>Figure 1: Docker architecture – the client talks to the Docker daemon, which manages images and containers. Images (for example Python, Redis) live in registries such as Docker Hub and can be pulled. Containers are runtime instances created from images and executed in isolation on the Docker host.</em></p>
<p><strong>Docker image.</strong> A Docker <em>image</em> is a <strong>read‑only template</strong> that describes everything required to spin up a container.<a href="https://docs.docker.com/get-started/docker-overview/#:~:text=">[1]</a> It is effectively a snapshot of a minimal filesystem plus configuration. Images can build on top of other images (start from <code>ubuntu</code>, add Apache, your application, and its configuration).<a href="https://docs.docker.com/get-started/docker-overview/#:~:text=">[1]</a> They are assembled incrementally: each image <strong>is composed of multiple filesystem layers</strong> stacked on top of one another (see section 4 for details).<a href="https://docs.docker.com/get-started/docker-overview/#:~:text=You%20might%20create%20your%20own,compared%20to%20other%20virtualization%20technologies">[2]</a> Crucially, an image is static and immutable: it never changes at runtime and serves as the template from which containers are launched.</p>
<p><strong>Docker container.</strong> A <em>container</em> is the <strong>runtime instance of an image</strong>.<a href="https://docs.docker.com/get-started/docker-overview/#:~:text=">[3]</a> If the image is the blueprint, the container is the concrete object being executed. Practically speaking, a container is an isolated process on the host machine with its own filesystem, network stack, and process tree.<a href="https://docs.docker.com/engine/containers/run/#:~:text=Docker%20runs%20processes%20in%20isolated,tree%20separate%20from%20the%20host">[4]</a> Docker uses the image as a base, creates a sandboxed environment, and runs your workload inside it. A helpful analogy is object-oriented programming: <strong>the image behaves like a class; the container is an instance of that class</strong>—the image defines, the container executes. You can create multiple containers from the same image (separate objects from one class) without them affecting one another; each keeps its own ephemeral state.<a href="https://circleci.com/blog/docker-image-vs-container/#:~:text=An%20image%20is%20a%20snapshot,a%20container%20runs%20the%20software">[5]</a></p>
<p><strong>Registry (image registry).</strong> A <em>registry</em> is a central service used to store and share container images.<a href="https://docs.docker.com/get-started/docker-overview/#:~:text=Docker%20registries">[6]</a> The default public registry is <strong>Docker Hub</strong>, which Docker consults automatically when an image is not available locally.<a href="https://docs.docker.com/get-started/docker-overview/#:~:text=Docker%20registries">[6]</a> Organisations often rely on alternative public or private registries: GitHub Container Registry, Amazon ECR, Google GCR, Azure ACR, or self-hosted Harbor. Inside a registry, images are organised into repositories (for instance <code>username/image</code> on Docker Hub identifies a repository). Public registries expose images to anyone, often curated with “official” images; private registries restrict access and are ideal for proprietary or internal images. In both scenarios Docker can authenticate when required and then perform <code>pull</code> (download) and <code>push</code> (upload) operations.</p>
<p><strong>How an image is built.</strong> Images are normally produced through a <code>docker build</code> process driven by a <strong>Dockerfile</strong>, a text file containing instructions that describe how to construct the image from a given base.<a href="https://docs.docker.com/get-started/docker-overview/#:~:text=You%20might%20create%20your%20own,compared%20to%20other%20virtualization%20technologies">[2]</a> Each instruction (for example <code>FROM</code>, <code>RUN</code>, <code>COPY</code>) is executed sequentially by the Docker daemon during the build and produces an additional filesystem layer.<a href="https://docs.docker.com/get-started/docker-overview/#:~:text=You%20might%20create%20your%20own,compared%20to%20other%20virtualization%20technologies">[2]</a> A sample Dockerfile might start with <code>FROM ubuntu:22.04</code> (base image), then <code>RUN apt-get install -y python3</code> (installs Python, creating a new layer with those files), followed by <code>COPY . /app</code> (copies the application into the image, adding another layer), and so on. Docker processes each instruction, “stacking” the results into the final image. The build leverages caching: if a step did not change, Docker reuses the existing layer instead of recomputing it, which makes rebuilds very fast.<a href="https://docs.docker.com/get-started/docker-overview/#:~:text=You%20might%20create%20your%20own,compared%20to%20other%20virtualization%20technologies">[2]</a> The resulting image is identified by a <strong>unique ID (a hash)</strong> that you can run or distribute. You can craft images from scratch (for instance starting from <code>scratch</code>, an empty image) or extend existing ones, promoting reuse of common components rather than reinventing baseline systems.</p>
<p><strong><code>docker pull</code> and <code>docker run</code>.</strong> Two essential commands when consuming images are <code>docker pull</code> and <code>docker run</code>.</p>
<ul>
<li><strong><code>docker pull</code>.</strong> The command <code>docker pull &lt;name:tag&gt;</code> downloads an image from a registry. Behind the scenes the Docker client contacts the registry via HTTP(S) and requests the image manifest (a file listing the layers composing the image). It then downloads each layer (called <em>blobs</em>) that is not already cached, often in parallel, and stores them locally.<a href="https://www.redhat.com/en/blog/pull-container-image#:~:text=When%20you%20initiate%20a%20pull%2C,a%20manifest%20from%20the%20registry">[7]</a> For example, <code>docker pull nginx:latest</code> fetches the list of layers for the Nginx image from Docker Hub and downloads them one by one; once complete, the image is ready on the host.</li>
<li><strong><code>docker run</code>.</strong> The command <code>docker run</code> creates and starts a container from an image. It is conceptually equivalent to running <code>docker pull</code> (if the image is missing) followed by <code>docker container create</code> and <code>docker container start</code>.<a href="https://docs.docker.com/get-started/docker-overview/#:~:text=When%20you%20run%20this%20command%2C,using%20the%20default%20registry%20configuration">[8]</a><a href="https://docs.docker.com/get-started/docker-overview/#:~:text=1,manually">[9]</a> When you execute <code>docker run ubuntu:22.04 echo &quot;hello&quot;</code>, Docker checks whether <code>ubuntu:22.04</code> exists locally; if not it pulls it from the registry.<a href="https://docs.docker.com/get-started/docker-overview/#:~:text=1,manually">[9]</a> The daemon then <strong>creates a container</strong> (allocating resources, preparing a writable filesystem layer, assigning an ID) and <strong>starts</strong> it by executing the specified command (in this case <code>echo &quot;hello&quot;</code>). When the process finishes the container stops; you can restart it or remove it entirely. In short, <code>docker run</code> orchestrates the download (if needed), creation, and execution of the workload in one step—the most common command in daily Docker usage.<a href="https://docs.docker.com/get-started/docker-overview/#:~:text=When%20you%20run%20this%20command%2C,using%20the%20default%20registry%20configuration">[8]</a><a href="https://docs.docker.com/get-started/docker-overview/#:~:text=1,manually">[9]</a></li>
</ul>
<h2>2. Container Lifecycle</h2>
<p><strong>From build to run (<code>docker run</code> under the hood).</strong> After building an image you move to the <em>run</em> phase, meaning you create and execute containers based on it. When <code>docker run</code> is invoked, Docker may pull the image first (if required). Internally the daemon performs the equivalent of <code>docker container create</code>: the container enters the <strong>Created</strong> state, resources are allocated, an ID is assigned, and a container-specific filesystem is prepared.<a href="https://docs.docker.com/get-started/docker-overview/#:~:text=1,manually">[9]</a> Docker then starts the container (similar to <code>docker container start</code>), launching the primary process defined in the image. At this point the container is in the <strong>Running</strong> state and executes the workload inside the isolated environment. The container stays running while that process is alive. When the process exits (voluntarily or due to a crash) or when you issue a stop command, Docker halts the container, which transitions to <strong>Stopped/Exited</strong>. A stopped container retains its isolated filesystem, logs, and state at the moment of shutdown and can be restarted. Finally, if you want to free the resources entirely you remove the container with <code>docker rm</code>, moving it to the <strong>Removed</strong> state: the container disappears from the host. The typical lifecycle therefore is <strong>Created → Running → Stopped/Exited → Removed</strong>.<a href="https://last9.io/blog/docker-container-lifecycle/#:~:text=Every%20container%20typically%20goes%20through,general%20flow%20stays%20the%20same">[10]</a> (Docker also offers a <strong>Paused</strong> state in which the container’s processes are frozen via the cgroups freezer, allowing you to temporarily suspend CPU usage without terminating them.<a href="https://last9.io/blog/docker-container-lifecycle/#:~:text=The%20Paused%20State">[11]</a> Pausing is less common; a container must be running to be paused and must be “unpaused” to resume.)</p>
<p><strong>Container states recap.</strong> The key states a Docker container can occupy during its lifecycle are:<a href="https://last9.io/blog/docker-container-lifecycle/#:~:text=Every%20container%20typically%20goes%20through,general%20flow%20stays%20the%20same">[10]</a></p>
<ul>
<li><strong>Created.</strong> The container definition and resources exist, but its process is not running yet. This happens via <code>docker create</code> or right after <code>docker run</code> before the workload starts. The container has an ID and filesystem but consumes minimal resources (no active process).</li>
<li><strong>Running.</strong> The container is active and its main process (PID 1 inside the container) is executing. It may expose network ports, consume CPU/RAM, and perform I/O—the “normal” state while serving applications.</li>
<li><strong>Stopped/Exited.</strong> The workload finished or the container was manually stopped. Nothing executes, yet the container still exists on the host with its filesystem intact. You can inspect it, read logs, or restart it. Containers that exit immediately because the command finishes also end up here.</li>
<li><strong>Removed.</strong> The container has been deleted from the host (<code>docker rm</code> or <code>docker run --rm</code>). It no longer appears in <code>docker ps -a</code> and no data remains (unless you used separate volumes). Any in-container changes that were not persisted externally are gone.</li>
</ul>
<p><strong>Copy-on-write and container filesystems.</strong> Docker relies on <strong>copy-on-write</strong> filesystems for containers. When a container is created Docker assembles a <strong>union filesystem</strong> composed of: all the image’s read-only layers plus a <strong>container-specific writable layer</strong>.<a href="https://www.digitalocean.com/community/tutorials/working-with-docker-containers#:~:text=Images%20come%20to%20life%20with,are%20taken%20to%20preserve%20them">[12]</a> The container sees a single unified filesystem (its root filesystem) that merges the image layers and the writable layer. If a process modifies or creates a file, copy-on-write kicks in: if the file already existed in one of the image’s read-only layers, Docker <strong>copies it into the writable layer</strong> and applies the change there, keeping the original intact.<a href="https://www.digitalocean.com/community/tutorials/working-with-docker-containers#:~:text=Images%20come%20to%20life%20with,are%20taken%20to%20preserve%20them">[12]</a> New files created by the container live solely in the writable layer. When you delete the container the writable layer disappears and those changes vanish (unless you mounted volumes to persist data). Conversely, you can inspect previous state by starting new containers from the same image: the read-only layers guarantee a clean, reproducible baseline every time.</p>
<h2>3. Internal Architecture</h2>
<p><strong>Isolation via namespaces and cgroups (Linux kernel).</strong> Docker builds isolation on native Linux features—primarily <em>namespaces</em> and <em>cgroups</em>. <strong>Namespaces</strong> allow the kernel to isolate system views and resources for groups of processes. When Docker creates a container, the kernel assigns dedicated namespaces.<a href="https://docs.docker.com/get-started/docker-overview/#:text=The%20underlying%20technology">[13]</a> Each namespace isolates a different aspect: the PID namespace gives the container its own process numbering (PID 1 inside the container is its main process, unaware of host processes),<a href="https://blog.nginx.org/blog/what-are-namespaces-cgroups-how-do-they-work#:~:text=Namespaces%20and%20Containers">[14]</a><a href="https://blog.nginx.org/blog/what-are-namespaces-cgroups-how-do-they-work#:~:text=The%20crucial%20thing%20to%20notice,isolated%20within%20my%20own%20namespace">[15]</a> the network namespace provides a virtual network interface with its own IP stack, the mount namespace offers an isolated filesystem view, and so on. Additional namespaces handle IPC, hostname (UTS), and optionally user mappings (user namespaces let a container run as “root” inside while mapping to an unprivileged UID on the host). Thanks to namespaces each container lives in a logical bubble: <strong>from the inside it only sees its own resources</strong>, not those of other containers or the host.<a href="https://blog.nginx.org/blog/what-are-namespaces-cgroups-how-do-they-work#:~:text=Namespaces%20and%20Containers">[14]</a> In parallel Docker leverages <strong>cgroups</strong> (control groups) to limit and monitor resource usage—CPU, memory, and I/O—for containers.<a href="https://blog.nginx.org/blog/what-are-namespaces-cgroups-how-do-they-work#:~:text=What%20Are%20cgroups%3F">[16]</a> Cgroups let the system cap how much CPU or RAM a container may consume, preventing any single workload from starving others,<a href="https://blog.nginx.org/blog/what-are-namespaces-cgroups-how-do-they-work#:~:text=A%20control%20group%20,of%20a%20collection%20of%20processes">[17]</a> provide resource accounting, and can freeze or terminate all container processes at once (for example <code>docker pause</code> uses the freezer cgroup).<a href="https://last9.io/blog/docker-container-lifecycle/#:~:text=The%20Paused%20State">[11]</a><a href="https://blog.nginx.org/blog/what-are-namespaces-cgroups-how-do-they-work#:~:text=,cgroup%20with%20a%20single%20command">[18]</a> Summing up: <strong>namespaces = isolation</strong> (processes, network, filesystem); <strong>cgroups = resource control</strong>. Combined, they let Docker create environments that behave like separate systems even though they share the same Linux kernel.</p>
<p><strong>Logical vs physical isolation (containers vs VMs).</strong> Container isolation is <em>logical/software</em> isolation rather than the <em>physical/hardware</em> isolation of traditional virtual machines. A container <strong>shares the host’s kernel</strong>: there is no separate OS instance per container, unlike a VM. Virtual machines virtualize an entire hardware stack and kernel, yielding stronger isolation at the cost of higher overhead; containers virtualize at the operating-system level, isolating processes and resources within the same kernel.<a href="https://aws.amazon.com/compare/the-difference-between-containers-and-virtual-machines/#:~:text=Containers%20virtualize%20the%20operating%20system,give%20some%20more%20differences%20below">[19]</a> In practice, containers deliver process isolation through namespaces/cgroups, whereas VMs provide full machine isolation with separate guest kernels atop a hypervisor. This means a kernel vulnerability is shared between containers and the host (so kernel exploits can theoretically break out of a container), while on VMs the guest kernel is isolated from the host. Conversely containers are much lighter: <strong>they start in seconds, consume only a few megabytes</strong>, and dozens can run on a single host without major waste, whereas a small number of VMs might exhaust resources quickly.<a href="https://circleci.com/blog/docker-image-vs-container/#:~:text=Since%20the%20container%20runs%20natively,you%20configure%20it%20that%20way">[20]</a><a href="https://aws.amazon.com/compare/the-difference-between-containers-and-virtual-machines/#:~:text=Containers%20virtualize%20the%20operating%20system,give%20some%20more%20differences%20below">[21]</a> Popular analogies liken containers to apartments in the same building (shared structure, isolated units) and VMs to detached houses (complete separation but higher cost).</p>
<h2>4. Docker Images as Layers</h2>
<p><strong>What a layer is and how it is stored.</strong> A Docker image is not a single monolithic blob: it is a <strong>stacked series of ordered layers</strong>. Every <em>layer</em> represents a set of <strong>filesystem changes</strong> relative to the layer below it.<a href="https://docs.docker.com/get-started/docker-concepts/building-images/understanding-image-layers/#:~:text=Each%20layer%20in%20an%20image,look%20at%20a%20theoretical%20image">[28]</a> Consider building an image for a Python application. The layers might look like this:<a href="https://docs.docker.com/get-started/docker-concepts/building-images/understanding-image-layers/#:~:text=Each%20layer%20in%20an%20image,look%20at%20a%20theoretical%20image">[28]</a></p>
<ul>
<li><strong>Layer 1:</strong> Minimal base OS (core commands and the package manager on Ubuntu).</li>
<li><strong>Layer 2:</strong> Installation of the Python interpreter and <code>pip</code>.</li>
<li><strong>Layer 3:</strong> Addition of <code>requirements.txt</code>.</li>
<li><strong>Layer 4:</strong> Installation of the Python dependencies listed in <code>requirements.txt</code>.</li>
<li><strong>Layer 5:</strong> Copy of the application source code into the target directory.</li>
</ul>
<p>In Dockerfile terms these correspond to <code>FROM ubuntu:22.04</code>, <code>RUN apt-get install python3 pip</code>, <code>COPY requirements.txt .</code>, <code>RUN pip install -r requirements.txt</code>, <code>COPY src/ .</code>. Docker creates a new layer for each instruction.<a href="https://docs.docker.com/get-started/docker-overview/#:~:text=You%20might%20create%20your%20own,compared%20to%20other%20virtualization%20technologies">[2]</a> Internally, Docker stores each layer as a compressed archive (typically a tarball) identified by a SHA256 digest. On disk (for example under <code>/var/lib/docker/overlay2/</code> when using overlay2) each layer is extracted into its own directory.<a href="https://www.adaltas.com/en/2021/06/03/linux-overlay-filesystem-docker/#:~:text=Docker%20uses%20the%20overlay%20filesystem,top%20of%20the%20image%20layers">[29]</a> Layers are <strong>immutable</strong>: once created they never change (any modification produces a brand-new layer). This design allows Docker to reuse unchanged layers when rebuilding images and only regenerate the ones that differ.<a href="https://docs.docker.com/get-started/docker-overview/#:~:text=with%20a%20simple%20syntax%20for,compared%20to%20other%20virtualization%20technologies">[30]</a><a href="https://docs.docker.com/get-started/docker-overview/#:~:text=it,compared%20to%20other%20virtualization%20technologies">[31]</a></p>
<p><strong>Layer caching and reuse.</strong> Layered images enable heavy reuse across builds and across different images. If two images start from <code>ubuntu:22.04</code>, the base layer is shared: Docker downloads or builds it once and reuses it everywhere.<a href="https://docs.docker.com/get-started/docker-concepts/building-images/understanding-image-layers/#:~:text=This%20is%20beneficial%20because%20it,look%20similar%20to%20the%20following">[32]</a> This drastically reduces disk space, bandwidth, and build times. During a build Docker computes the hash of the content produced at each step. When rebuilding, if a step is unchanged the cached layer is reused (you will see “Using cache” in the build output). If only the last instructions changed (for example the app code), Docker keeps the earlier layers and rebuilds the modified ones.<a href="https://docs.docker.com/get-started/docker-overview/#:~:text=with%20a%20simple%20syntax%20for,compared%20to%20other%20virtualization%20technologies">[30]</a><a href="https://docs.docker.com/get-started/docker-overview/#:~:text=it,compared%20to%20other%20virtualization%20technologies">[31]</a> The same principle applies to <code>docker pull</code>: when pulling an updated image Docker downloads only the new layers and reuses the existing ones, saving time and bandwidth during deployments.</p>
<p><strong>Practical example.</strong> Suppose you have a Dockerfile:</p>
<pre><code>FROM ubuntu:22.04
RUN apt-get update &amp;&amp; apt-get install -y nginx
COPY index.html /usr/share/nginx/html/index.html
</code></pre>
<p>During the build Docker executes:</p>
<ul>
<li><code>FROM ubuntu:22.04</code>: instructs Docker to use the Ubuntu base image (it already consists of its own minimal layers). These become the <strong>base layers</strong> of the new image.</li>
<li><code>RUN apt-get update &amp;&amp; apt-get install -y nginx</code>: Docker starts a temporary container from the base image, runs the commands, and captures the resulting filesystem changes (Nginx binaries, configuration files). Those changes form a <strong>new layer</strong> stacked on top.</li>
<li><code>COPY index.html ...</code>: Docker copies the local <code>index.html</code> file into the temporary container. The update becomes another <strong>final layer</strong>.</li>
</ul>
<p>The resulting image contains the Ubuntu layers, a layer for the Nginx installation, and a layer with the HTML file. If you build another similar image (for example another static site on Ubuntu + Nginx) Docker reuses the Ubuntu and Nginx layers and adds only the delta with the new files. At runtime multiple containers can share the read-only layers, while per-container differences stay in their writable layers. Layered images therefore underpin Docker’s <strong>portability</strong> (download only what you need), <strong>consistency</strong> (each layer is immutable and reproducible), and <strong>efficiency</strong> (maximum reuse of shared components).</p>
<h2>5. Registries and Distribution</h2>
<p><strong>What happens during <code>docker pull</code>.</strong> While we already described <code>docker pull</code>, let’s detail the flow. When you run <code>docker pull name:tag</code>, the client contacts the registry (Docker Hub by default, or another one specified in the reference) over HTTP APIs. The first step is requesting the image <strong>manifest</strong>—a JSON document listing the digests of all image layers plus metadata (configuration digest, architecture, etc.). The registry returns either a <em>manifest list</em> (also called an index, containing multiple manifests for different platforms) or a single manifest for a specific platform.<a href="https://www.redhat.com/en/blog/pull-container-image#:~:text=There%20are%20currently%20two%20types,and%20a%20manifest">[33]</a><a href="https://www.redhat.com/en/blog/pull-container-image#:~:text=Pull%20a%20manifest">[34]</a> If a manifest list is returned, Docker chooses the manifest matching the host platform (for example <code>linux/amd64</code> on an x86_64 PC).<a href="https://www.redhat.com/en/blog/pull-container-image#:~:text=Instead%20of%20blobs%2C%20the%20client,its%20operating%20system%20and%20architecture">[35]</a><a href="https://www.redhat.com/en/blog/pull-container-image#:~:text=Suppose%20a%20client%20chooses%20the,architecture%20and%20the%20manifest%20digest">[36]</a> Once the specific manifest is available, Docker <strong>downloads the layers</strong> listed there: for every layer digest it issues a GET request to fetch the corresponding blob.<a href="https://www.redhat.com/en/blog/pull-container-image#:~:text=When%20you%20initiate%20a%20pull%2C,a%20manifest%20from%20the%20registry">[7]</a> Layers are downloaded in parallel and stored in the local cache (typically under <code>/var/lib/docker/</code> in the active storage driver). Layers already present are skipped. After all blobs have arrived, Docker assembles or updates the local image metadata (writing the config JSON and referencing the local layer digests). The image is now ready to run. From the user’s perspective you see “Pull complete” for each layer and “Downloaded newer image for name:tag”. Summarising, <code>docker pull</code> orchestrates <strong>REST calls</strong>: manifest (or multi-arch index) first, then the layer blobs.<a href="https://www.redhat.com/en/blog/pull-container-image#:~:text=A%20Podman%20or%20Docker%20,image%20manifest%20is%20being%20pulled">[37]</a></p>
<p><strong>Public vs private registries.</strong> Public registries are open to everyone (subject to rate limits or authentication for pushing). They host official images, community builds, and shared artefacts. Security best practice is to pull only from trusted sources and verify image signatures (e.g. Docker Content Trust or Notary).<a href="https://help.sonatype.com/en/docker-content-trust.html#:~:text=Docker%20Content%20Trust">[42]</a><a href="https://www.cncf.io/blog/2021/07/28/enforcing-image-trust-on-docker-containers-using-notary/#:~:text=match%20at%20L267%20thus%20improving,container%20image%20trust%20using%20Docker">[43]</a> Private registries, on the other hand, restrict access to authenticated users or service accounts. They are used to store internal images (for example corporate microservices), enforce vulnerability scanning, integrate with CI/CD, and host multi-architecture builds tailored to company infrastructure. Regardless of visibility the distribution protocol is the same: manifests and layers are transferred over HTTPS.</p>
<p><strong><code>docker push</code> basics.</strong> When you execute <code>docker push</code>, Docker performs the inverse flow. It authenticates with the registry, checks which layers the registry already owns, and uploads only the missing ones. The manifest—referencing the layer digests—is uploaded last. Pushing large images efficiently often involves keeping the number of layers small and arranging Dockerfile instructions so that rarely-changing layers stay near the top of the Dockerfile (allowing maximum cache reuse downstream). CI/CD pipelines usually push images tagged with semantic versions plus immutable digests to preserve traceability.</p>
<h2>6. Conceptual Demo: What Happens When You <code>docker run nginx</code></h2>
<p>To consolidate the concepts, let’s walk through a <strong>step-by-step narrative</strong> of what happens when we execute:</p>
<pre><code>docker run nginx
</code></pre>
<p>What happens behind the scenes after you press Enter?</p>
<ol>
<li><p><strong>Image resolution.</strong> The Docker client interprets <code>nginx</code> as <code>nginx:latest</code> on the default registry (Docker Hub). It queries Docker Hub to see whether that image exists. Unless a fresh copy already exists locally, the daemon downloads the official Nginx image.<a href="https://docs.docker.com/get-started/docker-overview/#:~:text=1,manually">[9]</a> You will see progress bars for each layer (base Debian layer, Nginx binaries, etc.). After a few seconds <code>nginx:latest</code> is present on the host.</p>
</li>
<li><p><strong>Container creation.</strong> Once the pull is complete, Docker prepares a new container from that image—equivalent to running <code>docker container create nginx:latest</code>. It allocates space for the container by creating a directory for its writable layer, assigns a unique identifier (e.g. <code>d64f1abcbc23</code>), opens the network plumbing (port 80 internally, though not yet published), and sets runtime parameters (entrypoint, default environment variables, working directory) as defined by the image. The container is now in the <em>Created</em> state: it exists but nothing has executed yet.<a href="https://last9.io/blog/docker-container-lifecycle/#:~:text=The%20Created%20State">[44]</a> Docker has already built the container filesystem by overlaying the Nginx layers with a fresh writable layer.</p>
</li>
<li><p><strong>Isolation and resource wiring.</strong> Before starting Nginx, Docker configures isolation. It applies a PID namespace (Nginx will see itself as PID 1), a network namespace (creating a virtual <code>eth0</code> linked to the host bridge network so Nginx only talks through that isolated channel), a mount namespace (the container sees its own filesystem root), and others.<a href="https://docs.docker.com/get-started/docker-overview/#:~:text=The%20underlying%20technology">[13]</a> At the same time Docker wires default cgroup limits (by default containers can use host resources but are tracked in separate cgroups). Effectively Docker creates a dedicated execution bubble for Nginx.</p>
</li>
<li><p><strong>Process start inside the container.</strong> Docker now <em>starts</em> the container—equivalent to <code>docker start</code>. That runs the image’s entrypoint. The official Nginx image defines the entrypoint as the Nginx daemon in foreground mode (typically <code>nginx -g &quot;daemon off;&quot;</code>). Docker executes that binary inside the isolated container. From the host you see a new process (e.g. <code>nginx: master process nginx -g &#39;daemon off;&#39;</code> with some PID) belonging to the namespace-constrained environment. Inside the container the process is PID 1. Nginx loads its configuration (<code>/etc/nginx/nginx.conf</code>), opens port 80 <em>inside</em> the container, and starts listening. Because no port mapping was specified, Docker does not publish port 80 to the host; Nginx is reachable only from within the container or the internal bridge network. (<code>docker run -p 8080:80 nginx</code> would add a host-port mapping.)</p>
</li>
<li><p><strong>Container running state.</strong> At this stage the Nginx container is in the <strong>Running</strong> state. <code>docker ps</code> shows the container ID with status “Up X seconds”. Nginx operates as if it were on its own machine: attaching a shell (<code>docker exec -it &lt;container&gt; bash</code>) reveals a filesystem focused on Nginx, a small set of running processes (master + workers), a hostname matching the container ID, and a network namespace with an address like <code>172.17.x.y</code>. Another developer running <code>docker run nginx</code> elsewhere would obtain the same environment instantly, showcasing portability.</p>
</li>
<li><p><strong>Stopping and removing.</strong> When stopping the container you can either:</p>
<ul>
<li><code>docker stop &lt;container&gt;</code>: Docker sends <code>SIGTERM</code> to PID 1 inside the container (the Nginx master), waits the default grace period (10 seconds) and, if the process hasn’t exited, sends <code>SIGKILL</code>. The container transitions to Stopped and remains on disk (ready to restart with <code>docker start</code>).</li>
<li><code>docker rm -f &lt;container&gt;</code>: Docker forcibly removes the container, first sending <code>SIGKILL</code> (if running) and then deleting the writable layer. With <code>--rm</code>, removal happens automatically once the process exits.</li>
</ul>
<p>The writable layer is deleted, while read-only layers remain available for future containers. Logs produced by the container live under <code>/var/lib/docker/containers/&lt;id&gt;/</code>; once removed they are gone unless you configured logging drivers or volumes.</p>
</li>
<li><p><strong>Inspecting and debugging.</strong> While the container is running you can retrieve logs (<code>docker logs</code>), inspect configuration (<code>docker inspect</code>), check resource usage (<code>docker stats</code>), or enter the namespace (<code>docker exec</code>). These operations interact with the container without leaving the isolated environment; Docker handles the plumbing between host and container namespaces.</p>
</li>
</ol>
<p>This walk-through illustrates how Docker orchestrates image distribution, filesystem assembly, Linux isolation primitives, and process management in a seamless developer experience.</p>
<hr>
<p><strong>References</strong></p>
<p><a href="https://docs.docker.com/get-started/docker-overview/#:~:text=">[1]</a> Docker Docs – Docker overview<br><a href="https://docs.docker.com/get-started/docker-overview/#:~:text=You%20might%20create%20your%20own,compared%20to%20other%20virtualization%20technologies">[2]</a> Docker Docs – Build images<br><a href="https://docs.docker.com/get-started/docker-overview/#:~:text=">[3]</a> Docker Docs – What is a container<br><a href="https://docs.docker.com/engine/containers/run/#:~:text=Docker%20runs%20processes%20in%20isolated,tree%20separate%20from%20the%20host">[4]</a> Docker Docs – Run a container<br><a href="https://circleci.com/blog/docker-image-vs-container/#:~:text=An%20image%20is%20a%20snapshot,a%20container%20runs%20the%20software">[5]</a> CircleCI – Image vs container<br><a href="https://docs.docker.com/get-started/docker-overview/#:~:text=Docker%20registries">[6]</a> Docker Docs – Registries<br><a href="https://www.redhat.com/en/blog/pull-container-image#:~:text=When%20you%20initiate%20a%20pull%2C,a%20manifest%20from%20the%20registry">[7]</a> Red Hat – Pulling container images<br><a href="https://docs.docker.com/get-started/docker-overview/#:~:text=When%20you%20run%20this%20command%2C,using%20the%20default%20registry%20configuration">[8]</a> Docker Docs – <code>docker run</code> explained<br><a href="https://docs.docker.com/get-started/docker-overview/#:~:text=1,manually">[9]</a> Docker Docs – Pulling and running images<br><a href="https://last9.io/blog/docker-container-lifecycle/#:~:text=Every%20container%20typically%20goes%20through,general%20flow%20stays%20the%20same">[10]</a> Last9 – Container lifecycle<br><a href="https://last9.io/blog/docker-container-lifecycle/#:~:text=The%20Paused%20State">[11]</a> Last9 – Paused state<br><a href="https://www.digitalocean.com/community/tutorials/working-with-docker-containers#:~:text=Images%20come%20to%20life%20with,are%20taken%20to%20preserve%20them">[12]</a> DigitalOcean – Working with Docker containers<br><a href="https://docs.docker.com/get-started/docker-overview/#:~:text=The%20underlying%20technology">[13]</a> Docker Docs – Underlying technology<br><a href="https://blog.nginx.org/blog/what-are-namespaces-cgroups-how-do-they-work#:~:text=Namespaces%20and%20Containers">[14]</a> NGINX – Namespaces overview<br><a href="https://blog.nginx.org/blog/what-are-namespaces-cgroups-how-do-they-work#:~:text=The%20crucial%20thing%20to%20notice,isolated%20within%20my%20own%20namespace">[15]</a> NGINX – PID namespaces<br><a href="https://blog.nginx.org/blog/what-are-namespaces-cgroups-how-do-they-work#:~:text=What%20Are%20cgroups%3F">[16]</a> NGINX – cgroups intro<br><a href="https://blog.nginx.org/blog/what-are-namespaces-cgroups-how-do-they-work#:~:text=A%20control%20group%20,of%20a%20collection%20of%20processes">[17]</a> NGINX – Resource control<br><a href="https://blog.nginx.org/blog/what-are-namespaces-cgroups-how-do-they-work#:~:text=,cgroup%20with%20a%20single%20command">[18]</a> NGINX – Managing cgroups<br><a href="https://aws.amazon.com/compare/the-difference-between-containers-and-virtual-machines/#:~:text=Containers%20virtualize%20the%20operating%20system,give%20some%20more%20differences%20below">[19]</a> AWS – Containers vs VMs<br><a href="https://circleci.com/blog/docker-image-vs-container/#:~:text=Since%20the%20container%20runs%20natively,you%20configure%20it%20that%20way">[20]</a> CircleCI – Performance considerations<br><a href="https://aws.amazon.com/compare/the-difference-between-containers-and-virtual-machines/#:~:text=Containers%20virtualize%20the%20operating%20system,give%20some%20more%20differences%20below">[21]</a> AWS – Virtualization differences<br><a href="https://docs.docker.com/get-started/docker-concepts/building-images/understanding-image-layers/#:~:text=Each%20layer%20in%20an%20image,look%20at%20a%20theoretical%20image">[28]</a> Docker Docs – Image layers<br><a href="https://www.adaltas.com/en/2021/06/03/linux-overlay-filesystem-docker/#:text=Docker%20uses%20the%20overlay%20filesystem,top%20of%20the%20image%20layers">[29]</a> Adaltas – Overlay filesystem<br><a href="https://docs.docker.com/get-started/docker-overview/#:~:text=with%20a%20simple%20syntax%20for,compared%20to%20other%20virtualization%20technologies">[30]</a> Docker Docs – Build caching<br><a href="https://docs.docker.com/get-started/docker-overview/#:~:text=it,compared%20to%20other%20virtualization%20technologies">[31]</a> Docker Docs – Image reuse<br><a href="https://docs.docker.com/get-started/docker-concepts/building-images/understanding-image-layers/#:~:text=This%20is%20beneficial%20because%20it,look%20similar%20to%20the%20following">[32]</a> Docker Docs – Benefits of layering<br><a href="https://www.redhat.com/en/blog/pull-container-image#:~:text=There%20are%20currently%20two%20types,and%20a%20manifest">[33]</a> Red Hat – Manifest lists<br><a href="https://www.redhat.com/en/blog/pull-container-image#:~:text=Pull%20a%20manifest">[34]</a> Red Hat – Pulling manifests<br><a href="https://www.redhat.com/en/blog/pull-container-image#:~:text=Instead%20of%20blobs%2C%20the%20client,its%20operating%20system%20and%20architecture">[35]</a> Red Hat – Platform negotiation<br><a href="https://www.redhat.com/en/blog/pull-container-image#:~:text=Suppose%20a%20client%20chooses%20the,architecture%20and%20the%20manifest%20digest">[36]</a> Red Hat – Selecting the right manifest<br><a href="https://www.redhat.com/en/blog/pull-container-image#:~:text=A%20Podman%20or%20Docker%20,image%20manifest%20is%20being%20pulled">[37]</a> Red Hat – Registry downloads<br><a href="https://help.sonatype.com/en/docker-content-trust.html#:~:text=Docker%20Content%20Trust">[42]</a> Sonatype – Docker Content Trust<br><a href="https://www.cncf.io/blog/2021/07/28/enforcing-image-trust-on-docker-containers-using-notary/#:~:text=match%20at%20L267%20thus%20improving,container%20image%20trust%20using%20Docker">[43]</a> CNCF – Enforcing image trust<br><a href="https://last9.io/blog/docker-container-lifecycle/#:~:text=The%20Created%20State">[44]</a> Last9 – Created state explained</p>

    </article>
  </div>
</body>
</html>