<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TIR → Radianza → Temperatura (Tb) → Tsurf</title>
  <style>
    :root{
      --bg:#0b0f17;
      --muted:#93a4b8;
      --text:#e8eef6;
      --accent:#7dd3fc;
      --accent2:#a7f3d0;
      --warn:#fca5a5;
      --shadow: 0 14px 35px rgba(0,0,0,.35);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{margin:0}

    /* Embed-safe root: prevents blog CSS from breaking contrast */
    .tirviz-root{
      font-family: var(--sans);
      background: radial-gradient(1200px 800px at 20% 0%, #15203a 0%, var(--bg) 55%), var(--bg);
      color: var(--text);
      line-height: 1.45;
      padding: 28px 18px 60px;
    }

    .wrap{max-width:1100px;margin:0 auto;padding:0}

    header{
      display:flex;gap:16px;align-items:flex-end;justify-content:space-between;flex-wrap:wrap;
      margin-bottom:18px;
    }
    header h1{font-size:clamp(22px,3vw,34px);letter-spacing:-0.02em;margin:0}
    header p{margin:0;color:var(--muted);max-width:70ch}

    .grid{display:grid;grid-template-columns:1.2fr .8fr;gap:16px;align-items:start}
    @media (max-width: 960px){.grid{grid-template-columns:1fr}}

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border: 1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .hd{padding:16px 18px;border-bottom:1px solid rgba(255,255,255,.08);display:flex;align-items:center;justify-content:space-between;gap:12px}
    .card .hd h2{font-size:16px;margin:0;letter-spacing:-0.01em}
    .pill{font-size:12px;color:var(--muted);border:1px solid rgba(255,255,255,.14);padding:6px 10px;border-radius:999px}
    .card .bd{padding:16px 18px}

    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}

    .controls{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width: 520px){.controls{grid-template-columns:1fr}}

    .ctrl{
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 14px;
      padding: 12px;
    }
    .ctrl label{display:flex;justify-content:space-between;gap:10px;font-size:13px;color:var(--muted)}
    .ctrl input[type=range]{width:100%}
    .ctrl .val{font-family:var(--mono);color:var(--text)}

    .canvasWrap{position:relative}
    canvas{width:100%;height:auto;display:block;border-radius:16px;border:1px solid rgba(255,255,255,.10);background: rgba(0,0,0,.2)}
    .legend{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px;color:var(--muted);font-size:12px}
    .dot{width:10px;height:10px;border-radius:50%;display:inline-block;margin-right:6px;vertical-align:middle}

    .numbers{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px}
    @media (max-width: 520px){.numbers{grid-template-columns:1fr}}
    .num{
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 14px;
      padding: 12px;
    }
    .num .k{font-size:12px;color:var(--muted)}
    .num .v{font-family:var(--mono);font-size:15px;margin-top:6px}

    .note{color:var(--muted);font-size:13px;margin-top:10px}

    /* Pipeline */
    .pipelineGrid{display:grid;grid-template-columns:1fr;gap:10px}
    @media (min-width: 860px){
      .pipelineGrid{grid-template-columns:1fr 1fr;align-items:start}
    }

    .pipelineSteps{display:flex;flex-direction:column;gap:10px}
    .step{
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 16px;
      padding: 12px;
      position:relative;
      cursor:pointer;
      user-select:none;
      transition: border-color .15s ease, box-shadow .15s ease, transform .15s ease;
    }
    .step:hover{transform: translateY(-1px)}
    .step .t{font-weight:600;font-size:13px}
    .step .s{font-size:12px;color:var(--muted);margin-top:4px}
    .step.active{border-color: rgba(125, 211, 252, .55); box-shadow: 0 0 0 3px rgba(125, 211, 252, .10) inset;}

    .pipelineDetail{
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 16px;
      padding: 12px;
      min-height: 140px;
    }
    .pipelineDetail .h{font-weight:700;font-size:13px}
    .pipelineDetail .p{font-size:12px;color:var(--muted);margin-top:6px}
    .pipelineDetail .eq{font-family:var(--mono);font-size:12px;color:rgba(232,238,246,0.88);margin-top:10px;white-space:pre-wrap}

    /* SVG figure */
    .viz2{
      width:100%;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      padding:10px;
    }

    .footer{
      margin-top:18px;
      padding: 14px 18px;
      border-radius: 16px;
      border: 1px dashed rgba(255,255,255,.18);
      color: var(--muted);
      font-size: 13px;
    }

    .tirviz-root a{color:var(--accent)}
    .tirviz-root code{font-family:var(--mono)}
  </style>
</head>
<body>
  <div class="tirviz-root">
    <div class="wrap">
      <header>
        <div>
          <h1>Sensori TIR → Radianza → Temperatura</h1>
          <p>Nel TIR la sorgente non è il Sole: è la superficie stessa. Misurare la <b>radianza</b> equivale a misurare lo <b>stato termico</b>… ma l’inversione di Planck dà una <b>temperatura di brillanza</b> <code>Tb</code> se ignori emissività e atmosfera.</p>
        </div>
        <div class="pill">Embed‑ready • Vanilla HTML/CSS/JS</div>
      </header>

      <div class="grid">
        <!-- Left column: interactive plot -->
        <section class="card">
          <div class="hd">
            <h2>Interattivo: da T reale a Tb (e correzione)</h2>
            <span class="pill">8–14 µm</span>
          </div>
          <div class="bd">
            <div class="controls">
              <div class="ctrl">
                <label>
                  <span>Temperatura reale <code>Treal</code> (K)</span>
                  <span class="val" id="TrealVal">300</span>
                </label>
                <input id="Treal" type="range" min="240" max="330" step="1" value="300" />
                <div class="note">Tip: 300K ≈ 27°C</div>
              </div>
              <div class="ctrl">
                <label>
                  <span>Emissività <code>ε</code></span>
                  <span class="val" id="epsVal">0.93</span>
                </label>
                <input id="eps" type="range" min="0.85" max="1" step="0.01" value="0.93" />
                <div class="note">Acqua ≈ 0.98–0.99 • suolo nudo ≈ 0.90–0.95</div>
              </div>
              <div class="ctrl">
                <label>
                  <span>Trasmissività atmosfera <code>τ</code></span>
                  <span class="val" id="tauVal">0.85</span>
                </label>
                <input id="tau" type="range" min="0.60" max="1" step="0.01" value="0.85" />
                <div class="note">(Modello concettuale) τ↓ = più assorbimento/emissione (H₂O)</div>
              </div>
              <div class="ctrl">
                <label>
                  <span>Temperatura atmosfera <code>Tatm</code> (K)</span>
                  <span class="val" id="TatmVal">280</span>
                </label>
                <input id="Tatm" type="range" min="240" max="310" step="1" value="280" />
                <div class="note">Usata per la “path radiance” (emissione atmosferica)</div>
              </div>
            </div>

            <div class="canvasWrap" style="margin-top:14px">
              <canvas id="plot" width="980" height="520" aria-label="Grafico Planck e punto misurato"></canvas>
            </div>

            <div class="legend">
              <span><span class="dot" style="background: var(--accent)"></span>Corpo nero a <code>Treal</code> (Planck)</span>
              <span><span class="dot" style="background: var(--accent2)"></span>Radianza superficie <code>ε · Lbb</code></span>
              <span><span class="dot" style="background: var(--warn)"></span>Radianza al sensore <code>Lsens</code> (con τ + atmosfera)</span>
            </div>

            <div class="numbers">
              <div class="num">
                <div class="k">Radianza a 11 µm (corpo nero)</div>
                <div class="v" id="Lbb11">—</div>
              </div>
              <div class="num">
                <div class="k">Radianza misurata al sensore <code>Lsens</code> a 11 µm</div>
                <div class="v" id="Lsens11">—</div>
              </div>
              <div class="num">
                <div class="k">Temperatura di brillanza (inversione “naive”) <code>Tb</code></div>
                <div class="v" id="Tb">—</div>
              </div>
              <div class="num">
                <div class="k">Temperatura corretta (usando ε e τ del modello) <code>Tsurf</code></div>
                <div class="v" id="Tsurf">—</div>
              </div>
            </div>

            <div class="footer">
              <b>Nota</b>: questa demo è volutamente <i>didattica</i>.
              Il modello atmosferico è semplificato: <code>Lsens = τ·(ε·Lbb(Treal)) + (1−τ)·Lbb(Tatm)</code>.
              Nella realtà si usano profili atmosferici e/o algoritmi Split‑Window con regressioni/coefficenti calibrati.
            </div>
          </div>
        </section>

        <!-- Right column: visible vs TIR + pipeline -->
        <aside class="card">
          <div class="hd">
            <h2>Per capire “perché l’inversione”</h2>
            <span class="pill">visibile vs TIR</span>
          </div>
          <div class="bd">
            <svg class="viz2" viewBox="0 0 560 280" role="img" aria-label="Visibile vs TIR">
              <defs>
                <filter id="glow" x="-30%" y="-30%" width="160%" height="160%">
                  <feGaussianBlur stdDeviation="4" result="b" />
                  <feMerge>
                    <feMergeNode in="b" />
                    <feMergeNode in="SourceGraphic" />
                  </feMerge>
                </filter>
              </defs>

              <rect x="10" y="10" width="260" height="260" rx="18" fill="rgba(0,0,0,.18)" stroke="rgba(255,255,255,.10)"/>
              <rect x="290" y="10" width="260" height="260" rx="18" fill="rgba(0,0,0,.18)" stroke="rgba(255,255,255,.10)"/>

              <text x="28" y="38" fill="#e8eef6" font-size="14" font-weight="700">Visibile (RGB)</text>
              <text x="28" y="58" fill="#93a4b8" font-size="12">Sorgente: Sole → luce riflessa</text>

              <circle cx="70" cy="95" r="22" fill="#ffd84d" />
              <text x="102" y="100" fill="#93a4b8" font-size="12">Sole</text>

              <circle cx="165" cy="175" r="44" fill="#2563eb" opacity="0.95" />
              <circle cx="150" cy="168" r="14" fill="#22c55e" opacity="0.85" />
              <circle cx="180" cy="186" r="11" fill="#16a34a" opacity="0.85" />
              <text x="128" y="235" fill="#93a4b8" font-size="12">Terra</text>

              <path d="M88 110 L140 150" stroke="#ffd84d" stroke-width="6" stroke-linecap="round" />
              <path d="M182 175 L238 150" stroke="#e8eef6" stroke-width="6" stroke-linecap="round" opacity="0.7" />
              <text x="196" y="146" fill="#93a4b8" font-size="12">riflessa</text>

              <text x="308" y="38" fill="#e8eef6" font-size="14" font-weight="700">TIR (8–14 µm)</text>
              <text x="308" y="58" fill="#93a4b8" font-size="12">Sorgente: oggetto → energia emessa</text>

              <circle cx="385" cy="175" r="44" fill="#2563eb" opacity="0.95" />
              <circle cx="370" cy="168" r="14" fill="#22c55e" opacity="0.85" />
              <circle cx="400" cy="186" r="11" fill="#16a34a" opacity="0.85" />

              <rect x="470" y="92" width="62" height="44" rx="12" fill="rgba(0,0,0,.25)" stroke="rgba(255,255,255,.14)" />
              <text x="481" y="112" fill="#e8eef6" font-size="12" font-weight="700">Sensore</text>
              <text x="488" y="128" fill="#93a4b8" font-size="11">TIR</text>

              <path d="M430 164 C442 152, 454 176, 468 164 C482 152, 494 176, 508 164" stroke="#fb7185" stroke-width="5" fill="none" filter="url(#glow)" />
              <path d="M430 182 C442 170, 454 194, 468 182 C482 170, 494 194, 508 182" stroke="#fb7185" stroke-width="5" fill="none" opacity="0.8" />

              <text x="308" y="248" fill="#93a4b8" font-size="12">Nel TIR: misuro radianza → stimo temperatura</text>
            </svg>

            <div style="height:12px"></div>

            <div class="hd" style="padding:0;border:none;gap:10px;align-items:flex-start">
              <h2 style="margin:0;font-size:14px">Pipeline (clicca Play)</h2>
              <div class="row" style="margin-left:auto">
                <button id="play" style="all:unset;cursor:pointer;padding:8px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.14);background:rgba(0,0,0,.18);font-size:13px">▶ Play</button>
                <button id="stop" style="all:unset;cursor:pointer;padding:8px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.14);background:rgba(0,0,0,.18);font-size:13px">⏹ Stop</button>
              </div>
            </div>

            <div class="pipelineGrid" style="margin-top:10px">
              <div class="pipelineSteps" id="pipelineSteps">
                <div class="step" data-step="0"><div class="t">Fotoni TIR</div><div class="s">energia emessa dalla superficie</div></div>
                <div class="step" data-step="1"><div class="t">Rivelatore</div><div class="s">HgCdTe crio‑raffreddato</div></div>
                <div class="step" data-step="2"><div class="t">Corrente</div><div class="s">fotoni → elettroni</div></div>
                <div class="step" data-step="3"><div class="t">DN</div><div class="s">numero digitale</div></div>
                <div class="step" data-step="4"><div class="t">Gain & Offset</div><div class="s">calibrazione radiometrica</div></div>
                <div class="step" data-step="5"><div class="t">Lsens</div><div class="s">radianza al sensore</div></div>
                <div class="step" data-step="6"><div class="t">Inversione Planck</div><div class="s">trovo Tb</div></div>
                <div class="step" data-step="7"><div class="t">Correzioni</div><div class="s">ε + atmosfera → Tsurf</div></div>
              </div>

              <div class="pipelineDetail" id="pipelineDetail" aria-live="polite">
                <div class="h">Clicca Play (o un blocco)</div>
                <div class="p">Qui apparirà cosa rappresenta ogni step e perché serve l’inversione.</div>
                <div class="eq">Suggerimento: su mobile il pannello sta sotto la lista.</div>
              </div>
            </div>

            <div class="footer" style="margin-top:14px">
              <b>Perché “temperatura di brillanza”?</b><br/>
              <span style="color:var(--muted)">Perché l’inversione assume <code>ε=1</code> (corpo nero). Se <code>ε&lt;1</code>, a parità di <code>Treal</code> arriva meno radianza → l’inversione “naive” restituisce <code>Tb</code> più bassa.</span>
            </div>
          </div>
        </aside>
      </div>

      <div class="footer" style="margin-top:18px">
        <b>Come inserirla nel blog</b><br/>
        1) Copia questo file in <code>tir-viz.html</code> e includilo con un <code>&lt;iframe&gt;</code> (consigliato).<br/>
        <code>&lt;iframe src="/path/tir-viz.html" style="width:100%;height:980px;border:0" loading="lazy"&gt;&lt;/iframe&gt;</code><br/>
        2) Oppure incolla direttamente l’HTML nel post (se la piattaforma lo permette).
      </div>
    </div>
  </div>

<script>
  'use strict';

  // ------------------------------
  // Physics: Planck + inversion (brightness temperature)
  // ------------------------------
  const H  = 6.62607015e-34;     // J*s
  const C  = 2.99792458e8;       // m/s
  const KB = 1.380649e-23;       // J/K

  function planckLambda(lam_m, T){
    // L_lambda [W sr^-1 m^-3]
    const a = 2 * H * C * C;
    const b = (H * C) / (lam_m * KB * T);
    return a / (Math.pow(lam_m, 5) * (Math.exp(b) - 1));
  }

  function invertPlanckLambda(L, lam_m){
    const num = H * C;
    const den = KB * lam_m * Math.log((2 * H * C * C) / (Math.pow(lam_m, 5) * L) + 1);
    return num / den;
  }

  function fmtW(x){
    const p = x.toExponential(3);
    return p.replace('e', '×10^');
  }

  // ------------------------------
  // Minimal self-tests (console)
  // ------------------------------
  function runSelfTests(){
    const approx = (a,b,tol)=>Math.abs(a-b) <= tol;

    // Test 1: inversion(Planck(T)) ≈ T at 11µm
    {
      const lam = 11e-6;
      const T = 300;
      const L = planckLambda(lam, T);
      const Tb = invertPlanckLambda(L, lam);
      console.assert(approx(Tb, T, 1e-6), `Test1 failed: Tb=${Tb} vs T=${T}`);
    }

    // Test 2: forward + reverse simple atmosphere returns ~T
    {
      const lam = 11e-6;
      const Treal = 300;
      const Tatm = 280;
      const eps = 0.93;
      const tau = 0.85;
      const Lbb = planckLambda(lam, Treal);
      const Latm = planckLambda(lam, Tatm);
      const Lsens = tau * (eps * Lbb) + (1 - tau) * Latm;

      const Lsurf_est = (Lsens - (1 - tau) * Latm) / tau;
      const Lbb_est = Lsurf_est / eps;
      const Tsurf = invertPlanckLambda(Lbb_est, lam);

      console.assert(approx(Tsurf, Treal, 1e-6), `Test2 failed: Tsurf=${Tsurf} vs Treal=${Treal}`);
    }
  }

  // ------------------------------
  // UI wiring
  // ------------------------------
  const el = (id)=>document.getElementById(id);
  const sliders = {
    Treal: el('Treal'),
    eps: el('eps'),
    tau: el('tau'),
    Tatm: el('Tatm'),
  };
  const outputs = {
    TrealVal: el('TrealVal'),
    epsVal: el('epsVal'),
    tauVal: el('tauVal'),
    TatmVal: el('TatmVal'),
    Lbb11: el('Lbb11'),
    Lsens11: el('Lsens11'),
    Tb: el('Tb'),
    Tsurf: el('Tsurf'),
  };

  // ------------------------------
  // Pipeline animation + detail panel
  // ------------------------------
  const steps = Array.from(document.querySelectorAll('.step[data-step]'));
  const detail = document.getElementById('pipelineDetail');

  const PIPE = [
    {
      h: 'Fotoni TIR',
      p: 'La superficie (con T > 0 K) emette radiazione nel termico. Nel TIR la sorgente è l’oggetto, non il Sole.',
      eq: 'Idea: misuro Lλ ⇒ stato termico della superficie.'
    },
    {
      h: 'Rivelatore (HgCdTe)',
      p: 'Un fotodiodo sensibile all’infrarosso, spesso HgCdTe, spesso raffreddato per ridurre il rumore.',
      eq: 'fotoni IR → elettroni (raffreddamento → meno rumore)'
    },
    {
      h: 'Corrente elettrica',
      p: 'I fotoni generano portatori di carica → una corrente proporzionale al flusso/radianza che arriva.',
      eq: 'fotoni → e⁻ → I(t)'
    },
    {
      h: 'DN (Digital Number)',
      p: 'L’elettronica converte il segnale in un numero digitale (DN). È ancora “strumentale”, non fisico.',
      eq: 'ADC: segnale analogico → DN'
    },
    {
      h: 'Gain & Offset',
      p: 'Calibrazione radiometrica: DN viene convertito in radianza al sensore tramite parametri di calibrazione.',
      eq: 'Lsens = Gain · DN + Offset'
    },
    {
      h: 'Radianza al sensore (Lsens)',
      p: 'È la radianza vista dal sensore: include emissività della superficie + contributi atmosferici (assorbimento/emissione).',
      eq: 'Esempio didattico: Lsens = τ·(ε·Lbb) + (1−τ)·Latm'
    },
    {
      h: 'Inversione di Planck → Tb',
      p: 'Il sensore non “sa” la temperatura. Invertiamo Planck e chiediamo: quale T di corpo nero produce la L misurata?',
      eq: 'Tb = hc / [kB·λ·ln( (2hc²)/(λ⁵Lλ) + 1 )]'
    },
    {
      h: 'Correzioni → Tsurf',
      p: 'Tb assume ε=1 (corpo nero). Per ottenere T reale serve correggere per emissività e atmosfera (es. split‑window).',
      eq: 'Tsurf = f(Tb, ε, atmosfera)'
    }
  ];

  let timer = null;

  function clearActive(){
    steps.forEach(s=>s.classList.remove('active'));
  }

  function setDetail(i){
    const d = PIPE[i] || PIPE[0];
    detail.innerHTML = `
      <div class="h">${d.h}</div>
      <div class="p">${d.p}</div>
      <div class="eq">${d.eq}</div>
    `;
  }

  function activate(i){
    clearActive();
    const s = document.querySelector(`.step[data-step="${i}"]`);
    if(s) s.classList.add('active');
    setDetail(i);
  }

  steps.forEach(s=>{
    s.addEventListener('click', ()=>{
      const i = Number(s.getAttribute('data-step'));
      if(timer){
        clearInterval(timer);
        timer = null;
      }
      activate(i);
    });
  });

  el('play').addEventListener('click', ()=>{
    if(timer) return;
    let i = 0;
    activate(i);
    timer = setInterval(()=>{
      i = (i + 1) % PIPE.length;
      activate(i);
    }, 850);
  });

  el('stop').addEventListener('click', ()=>{
    if(timer){
      clearInterval(timer);
      timer = null;
    }
    clearActive();
  });

  // ------------------------------
  // Plot
  // ------------------------------
  const canvas = el('plot');
  const ctx = canvas.getContext('2d');

  function draw(){
    const Treal = Number(sliders.Treal.value);
    const eps   = Number(sliders.eps.value);
    const tau   = Number(sliders.tau.value);
    const Tatm  = Number(sliders.Tatm.value);

    outputs.TrealVal.textContent = String(Treal);
    outputs.epsVal.textContent   = eps.toFixed(2);
    outputs.tauVal.textContent   = tau.toFixed(2);
    outputs.TatmVal.textContent  = String(Tatm);

    const lamMinUm = 8.0, lamMaxUm = 14.0;
    const N = 420;
    const lamUm = new Array(N);
    const Lbb = new Array(N);
    const Lsurf = new Array(N);
    const Lsens = new Array(N);

    let Lmax = 0;
    for(let i=0;i<N;i++){
      const u = i/(N-1);
      const lam = lamMinUm + u*(lamMaxUm - lamMinUm);
      const lm = lam*1e-6;
      const L = planckLambda(lm, Treal);
      const Latm = planckLambda(lm, Tatm);
      const L_surf = eps * L;
      const L_sens = tau * L_surf + (1 - tau) * Latm;

      lamUm[i]=lam;
      Lbb[i]=L;
      Lsurf[i]=L_surf;
      Lsens[i]=L_sens;

      Lmax = Math.max(Lmax, L, L_surf, L_sens);
    }

    // point at 11 µm
    const lamMeas = 11.0;
    const lamMeasM = lamMeas * 1e-6;
    const Lbb11 = planckLambda(lamMeasM, Treal);
    const Latm11 = planckLambda(lamMeasM, Tatm);
    const Lsens11 = tau * (eps * Lbb11) + (1 - tau) * Latm11;

    // brightness temperature (naive)
    const Tb = invertPlanckLambda(Math.max(Lsens11, 1e-30), lamMeasM);

    // corrected (invert our didactic atmosphere)
    const Lsurf_est = (Lsens11 - (1 - tau) * Latm11) / Math.max(tau, 1e-6);
    const Lbb_est = Lsurf_est / Math.max(eps, 1e-6);
    const Tsurf = invertPlanckLambda(Math.max(Lbb_est, 1e-30), lamMeasM);

    outputs.Lbb11.textContent = fmtW(Lbb11) + " W·sr⁻¹·m⁻³";
    outputs.Lsens11.textContent = fmtW(Lsens11) + " W·sr⁻¹·m⁻³";
    outputs.Tb.textContent = Tb.toFixed(2) + " K";
    outputs.Tsurf.textContent = Tsurf.toFixed(2) + " K";

    const W = canvas.width, Hh = canvas.height;
    ctx.clearRect(0,0,W,Hh);

    const m = {l:70, r:18, t:18, b:54};
    const pw = W - m.l - m.r;
    const ph = Hh - m.t - m.b;

    // grid
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.lineWidth = 1;
    for(let g=0; g<=5; g++){
      const y = m.t + ph * (g/5);
      ctx.beginPath(); ctx.moveTo(m.l, y); ctx.lineTo(W-m.r, y); ctx.stroke();
    }
    ctx.beginPath();
    ctx.moveTo(m.l, m.t+ph);
    ctx.lineTo(W-m.r, m.t+ph);
    ctx.stroke();

    // labels
    ctx.fillStyle = 'rgba(232,238,246,0.85)';
    ctx.font = '12px ' + getComputedStyle(document.documentElement).getPropertyValue('--mono');
    ctx.fillText('λ (µm)', W-70, Hh-18);
    ctx.save();
    ctx.translate(18, m.t+ph/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText('Lλ (normalizzata)', 0, 0);
    ctx.restore();

    // ticks
    for(let x=8; x<=14; x++){
      const px = m.l + (x-lamMinUm)/(lamMaxUm-lamMinUm) * pw;
      ctx.fillStyle = 'rgba(255,255,255,0.45)';
      ctx.fillText(String(x), px-4, Hh-30);
      ctx.strokeStyle = 'rgba(255,255,255,0.14)';
      ctx.beginPath(); ctx.moveTo(px, m.t+ph); ctx.lineTo(px, m.t+ph+6); ctx.stroke();
    }
    ctx.restore();

    const X = (lam)=> m.l + (lam-lamMinUm)/(lamMaxUm-lamMinUm) * pw;
    const Y = (L)=> m.t + (1 - (L/Lmax)) * ph;

    function drawCurve(arr, stroke, width, alpha){
      ctx.save();
      ctx.strokeStyle = stroke;
      ctx.lineWidth = width;
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      for(let i=0;i<N;i++){
        const x = X(lamUm[i]);
        const y = Y(arr[i]);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.restore();
    }

    const css = getComputedStyle(document.documentElement);
    const accent  = css.getPropertyValue('--accent').trim();
    const accent2 = css.getPropertyValue('--accent2').trim();
    const warn    = css.getPropertyValue('--warn').trim();

    drawCurve(Lbb,   accent,  3.5, 0.90);
    drawCurve(Lsurf, accent2, 3.0, 0.85);
    drawCurve(Lsens, warn,    3.2, 0.90);

    // vertical @ 11µm
    const x11 = X(lamMeas);
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.setLineDash([6,6]);
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(x11, m.t); ctx.lineTo(x11, m.t+ph); ctx.stroke();
    ctx.restore();

    // measured point
    const y11 = Y(Lsens11);
    ctx.save();
    ctx.fillStyle = warn;
    ctx.beginPath(); ctx.arc(x11, y11, 6, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = 'rgba(232,238,246,0.85)';
    ctx.font = '12px ' + getComputedStyle(document.documentElement).getPropertyValue('--mono');
    ctx.fillText('misura @ 11µm', x11+10, y11-10);
    ctx.restore();

    // callout
    const boxW = 310, boxH = 78;
    const bx = W - boxW - 18;
    const by = 22;

    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.strokeStyle = 'rgba(255,255,255,0.14)';
    ctx.lineWidth = 1;
    roundRect(ctx, bx, by, boxW, boxH, 14);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = 'rgba(232,238,246,0.92)';
    ctx.font = '600 13px ' + getComputedStyle(document.documentElement).getPropertyValue('--sans');
    ctx.fillText('Inversione Planck (naive)', bx+14, by+24);

    ctx.font = '12px ' + getComputedStyle(document.documentElement).getPropertyValue('--mono');
    ctx.fillStyle = 'rgba(232,238,246,0.86)';
    ctx.fillText(`Treal = ${Treal.toFixed(0)} K`, bx+14, by+46);
    ctx.fillText(`Tb   = ${Tb.toFixed(2)} K`, bx+14, by+64);

    const mismatch = Tb - Treal;
    ctx.fillStyle = mismatch < -0.2 ? 'rgba(252,165,165,0.95)' : 'rgba(167,243,208,0.92)';
    ctx.fillText(`Δ = ${mismatch.toFixed(2)} K`, bx+170, by+64);

    ctx.restore();

    function roundRect(ctx, x, y, w, h, r){
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y, x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x, y+h, r);
      ctx.arcTo(x, y+h, x, y, r);
      ctx.arcTo(x, y, x+w, y, r);
      ctx.closePath();
    }
  }

  // init
  runSelfTests();
  Object.values(sliders).forEach(s=>s.addEventListener('input', draw));
  draw();
</script>
</body>
</html>
