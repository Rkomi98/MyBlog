<!DOCTYPE html>
<html lang="it" translate="no">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Elixir Cheatsheet | Mirko Calcaterra</title>
  <meta name="description" content="Elixir Cheatsheet Se stai leggendo questo articolo, probabilmente hai sentito parlare di Elixir, quel linguaggio che unisce la sintassi elegante di Ruby con la potenza bruta e la concorrenza (questo termine in italiano √® veramente cacofonico) di Erlang. O for‚Ä¶">
  <meta name="keywords" content="Elixir, Programmazione, Cheatsheet, BEAM, Mirko Calcaterra, Functional Programming">
  <meta name="author" content="Mirko Calcaterra">
  <link rel="canonical" href="${pageUrl}">

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-9EVQ8G9W48"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-9EVQ8G9W48');
  </script>

  <!-- Open Graph -->
  <meta property="og:type" content="article">
  <meta property="og:url" content="https://rkomi98.github.io/MyBlog/blog/it/elixir-cheatsheet/">
  <meta property="og:title" content="Elixir Cheatsheet">
  <meta property="og:description" content="Elixir Cheatsheet Se stai leggendo questo articolo, probabilmente hai sentito parlare di Elixir, quel linguaggio che unisce la sintassi elegante di Ruby con la potenza bruta e la concorrenza (questo termine in italiano √® veramente cacofonico) di Erlang. O for‚Ä¶">
  <meta property="og:image" content="https://rkomi98.github.io/MyBlog/Assets/Logo.png">
  <meta property="article:published_time" content="2026-01-23T00:00:00.000Z">
  <meta property="article:author" content="Mirko Calcaterra">
  <meta property="article:section" content="Programmazione">

  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:title" content="Elixir Cheatsheet">
  <meta property="twitter:description" content="Elixir Cheatsheet Se stai leggendo questo articolo, probabilmente hai sentito parlare di Elixir, quel linguaggio che unisce la sintassi elegante di Ruby con la potenza bruta e la concorrenza (questo termine in italiano √® veramente cacofonico) di Erlang. O for‚Ä¶">
  <meta property="twitter:image" content="https://rkomi98.github.io/MyBlog/Assets/Logo.png">

  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "headline": "Elixir Cheatsheet",
    "image": "https://rkomi98.github.io/MyBlog/Assets/Logo.png",
    "datePublished": "2026-01-23T00:00:00.000Z",
    "dateModified": "2026-01-23T22:09:34.428Z",
    "author": {
      "@type": "Person",
      "name": "Mirko Calcaterra",
      "url": "https://rkomi98.github.io/MyBlog/"
    },
    "publisher": {
      "@type": "Person",
      "name": "Mirko Calcaterra"
    },
    "description": "Elixir Cheatsheet Se stai leggendo questo articolo, probabilmente hai sentito parlare di Elixir, quel linguaggio che unisce la sintassi elegante di Ruby con la potenza bruta e la concorrenza (questo termine in italiano √® veramente cacofonico) di Erlang. O for‚Ä¶"
  }
  </script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      box-sizing: border-box;
    }
    html {
      scroll-behavior: smooth;
    }
    body {
      margin: 0;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: radial-gradient(120% 120% at 50% 0%, rgba(59, 130, 246, 0.18) 0%, transparent 65%), var(--bg-primary);
      color: var(--text-primary);
      transition: background 0.3s ease, color 0.3s ease;
      --bg-primary: #0f172a;
      --bg-secondary: #111c33;
      --bg-card: rgba(15, 23, 42, 0.78);
      --bg-card-strong: rgba(15, 23, 42, 0.9);
      --border: rgba(148, 163, 184, 0.24);
      --text-primary: #e2e8f0;
      --text-secondary: #cbd5f5;
      --text-muted: #94a3b8;
      --accent: #60a5fa;
      --accent-strong: #38bdf8;
      --shadow-lg: 0 28px 60px -36px rgba(15, 23, 42, 0.9);
      --code-inline-bg: rgba(6, 11, 19, 0.92);
      --code-block-bg: #050912;
      --code-border: rgba(148, 163, 184, 0.35);
      --code-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.12);
      --code-text: #f8fafc;
    }
    body[data-theme="light"] {
      --bg-primary: #f8fafc;
      --bg-secondary: #ffffff;
      --bg-card: rgba(255, 255, 255, 0.96);
      --bg-card-strong: rgba(248, 250, 252, 0.98);
      --border: rgba(148, 163, 184, 0.18);
      --text-primary: #0f172a;
      --text-secondary: #334155;
      --text-muted: #64748b;
      --accent: #2563eb;
      --accent-strong: #1d4ed8;
      --shadow-lg: 0 28px 50px -38px rgba(15, 23, 42, 0.18);
      background: radial-gradient(120% 120% at 50% 0%, rgba(59, 130, 246, 0.12) 0%, transparent 60%), var(--bg-primary);
    }
    body[data-theme="light"] .post-toc {
      background: rgba(255, 255, 255, 0.96);
    }
    body[data-theme="light"] .post-body {
      background: rgba(255, 255, 255, 0.96);
      color: var(--text-secondary);
    }
    body[data-theme="light"] .post-hero__category {
      background: rgba(37, 99, 235, 0.12);
      color: var(--accent-strong);
    }
    body[data-theme="light"] .post-body blockquote {
      background: rgba(37, 99, 235, 0.1);
      color: var(--text-primary);
    }
    a {
      color: inherit;
      text-decoration: none;
    }
    header.site-header {
      position: sticky;
      top: 0;
      z-index: 12;
      backdrop-filter: blur(14px);
      background: rgba(15, 23, 42, 0.85);
      border-bottom: 1px solid var(--border);
      transition: background 0.3s ease;
    }
    body[data-theme="light"] header.site-header {
      background: rgba(248, 250, 252, 0.9);
    }
    .site-header__inner {
      max-width: 1200px;
      margin: 0 auto;
      padding: 1.15rem clamp(1.5rem, 3vw, 3rem);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1.5rem;
    }
    .site-header__left {
      display: flex;
      align-items: center;
      gap: 1.75rem;
    }
    .logo {
      display: inline-flex;
      align-items: center;
      gap: 0.7rem;
      font-weight: 600;
      color: var(--text-primary);
      font-size: 1.05rem;
      letter-spacing: 0.01em;
    }
    .logo-img {
      width: 38px;
      height: 38px;
      border-radius: 12px;
      object-fit: cover;
      box-shadow: 0 8px 18px -12px rgba(15, 23, 42, 0.6);
    }
    .site-nav {
      display: flex;
      gap: 1.1rem;
      font-size: 0.95rem;
      font-weight: 500;
      color: var(--text-muted);
    }
    .site-nav a:hover {
      color: var(--accent);
    }
    .header-controls {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    .lang-btn {
      border: 1px solid var(--border);
      background: var(--bg-card);
      color: var(--text-primary);
      padding: 0.45rem 0.9rem;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border 0.2s ease, transform 0.2s ease;
    }
    .lang-btn:hover:not(.lang-btn--disabled) {
      background: var(--accent);
      color: #ffffff;
      transform: translateY(-1px);
      border-color: transparent;
    }
    .lang-btn--disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .theme-toggle {
      position: relative;
      width: 52px;
      height: 28px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--bg-card);
      cursor: pointer;
      padding: 0;
      transition: background 0.3s ease, border 0.3s ease;
      display: flex;
      align-items: center;
    }
    .theme-toggle .theme-thumb {
      position: absolute;
      top: 50%;
      left: 4px;
      transform: translateY(-50%);
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #ffffff;
      color: #1f2937;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      transition: transform 0.3s ease, background 0.3s ease, color 0.3s ease;
      box-shadow: 0 6px 18px -8px rgba(15, 23, 42, 0.6);
    }
    body[data-theme="dark"] .theme-toggle .theme-thumb {
      transform: translate(20px, -50%);
      background: #1f2937;
      color: #f8fafc;
    }
    body[data-theme="dark"] .theme-toggle {
      background: rgba(37, 99, 235, 0.2);
      border-color: rgba(37, 99, 235, 0.3);
    }
    main.page {
      max-width: 1200px;
      margin: 0 auto;
      padding: 3.5rem clamp(1.5rem, 3vw, 3rem) 4.5rem;
    }
    .post-hero {
      position: relative;
      overflow: hidden;
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.22) 0%, rgba(14, 165, 233, 0.08) 60%), var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 28px;
      padding: 2.75rem;
      box-shadow: var(--shadow-lg);
      margin-bottom: 3rem;
    }
    .post-hero::after {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 20% 20%, rgba(59, 130, 246, 0.22) 0%, transparent 55%);
      pointer-events: none;
    }
    .post-hero__icon {
      position: relative;
      font-size: 3.1rem;
      margin-bottom: 1.5rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .post-hero__category {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.4rem 1rem;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.35);
      color: #ffffff;
      font-weight: 600;
      letter-spacing: 0.02em;
      margin-bottom: 1.25rem;
      text-transform: uppercase;
      font-size: 0.8rem;
    }
    .post-hero__title {
      position: relative;
      margin: 0 0 1.25rem;
      font-size: clamp(2.4rem, 4vw, 3.2rem);
      letter-spacing: -0.025em;
      line-height: 1.2;
      color: var(--text-primary);
    }
    .post-hero__meta {
      position: relative;
      display: flex;
      flex-wrap: wrap;
      gap: 1.25rem;
      color: var(--text-muted);
      font-size: 0.95rem;
      font-weight: 500;
    }
    .post-hero__meta span {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
    }
    .post-layout {
      display: grid;
      grid-template-columns: minmax(220px, 300px) minmax(0, 1fr);
      gap: 2.75rem;
      align-items: flex-start;
    }
    .post-layout--single {
      grid-template-columns: minmax(0, 1fr);
    }
    .post-toc {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 22px;
      padding: 1.5rem 1.6rem 1.8rem;
      box-shadow: var(--shadow-lg);
      position: sticky;
      top: 120px;
      max-height: calc(100vh - 160px);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .post-toc__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      margin-bottom: 0.5rem;
    }
    .post-toc__title {
      text-transform: uppercase;
      font-size: 0.78rem;
      letter-spacing: 0.18em;
      font-weight: 700;
      color: var(--text-muted);
    }
    .post-toc__toggle {
      display: none;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text-secondary);
      border-radius: 999px;
      padding: 0.25rem 0.8rem;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      align-items: center;
      gap: 0.4rem;
      transition: background 0.2s ease, border 0.2s ease, color 0.2s ease;
    }
    .post-toc__toggle:hover {
      background: rgba(96, 165, 250, 0.15);
      border-color: transparent;
      color: var(--accent);
    }
    .post-toc__content {
      margin-top: 0.6rem;
      overflow-y: auto;
      padding-right: 0.4rem;
      transition: max-height 0.25s ease, opacity 0.25s ease;
      max-height: calc(100vh - 220px);
    }
    .post-toc--collapsed .post-toc__content {
      max-height: 0;
      opacity: 0;
      margin-top: 0;
      pointer-events: none;
    }
    .post-toc__list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
    }
    .post-toc__sublist {
      margin-left: 0.85rem;
      padding-left: 0.85rem;
      border-left: 1px solid rgba(148, 163, 184, 0.35);
      margin-top: 0.4rem;
      gap: 0.35rem;
    }
    .post-toc__item {
      margin: 0;
    }
    .post-toc__link {
      color: var(--text-secondary);
      font-size: 0.95rem;
      line-height: 1.45;
      display: flex;
      align-items: flex-start;
      gap: 0.5rem;
      border-bottom: 1px dashed transparent;
      transition: color 0.2s ease, border-bottom 0.2s ease, transform 0.2s ease;
    }
    .post-toc__link:hover {
      color: var(--accent);
      border-bottom-color: rgba(96, 165, 250, 0.4);
      transform: translateX(2px);
    }
    .post-toc__link--active {
      color: var(--accent-strong);
      border-bottom-color: var(--accent-strong);
    }
    .post-toc__number {
      font-variant-numeric: tabular-nums;
      font-size: 0.85rem;
      color: var(--text-muted);
      min-width: 2.5ch;
      display: inline-flex;
      justify-content: flex-end;
      padding-top: 0.15rem;
    }
    .post-toc__text {
      flex: 1;
    }
    .post-body {
      background: var(--bg-card-strong);
      border: 1px solid var(--border);
      border-radius: 26px;
      padding: 2.5rem;
      box-shadow: var(--shadow-lg);
      font-size: 1.04rem;
      line-height: 1.75;
      color: var(--text-secondary);
    }
    .post-body h2 {
      margin-top: 2.75rem;
      margin-bottom: 1.25rem;
      font-size: clamp(1.9rem, 3vw, 2.35rem);
      color: var(--text-primary);
      letter-spacing: -0.01em;
    }
    .post-body h3 {
      margin-top: 2.2rem;
      margin-bottom: 1rem;
      font-size: 1.5rem;
      color: var(--text-primary);
    }
    .post-body h4 {
      margin-top: 1.8rem;
      margin-bottom: 0.75rem;
      font-size: 1.2rem;
      color: var(--text-primary);
    }
    .post-body p {
      margin-bottom: 1.4rem;
    }
    .post-body .post-warning {
      margin: 2rem 0;
      border-radius: 18px;
      border: 1px solid rgba(250, 204, 21, 0.35);
      background: rgba(254, 243, 199, 0.9);
      color: #4a3b0a;
      padding: 0 1.25rem 1rem;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.35);
    }
    body[data-theme="dark"] .post-body .post-warning {
      background: rgba(253, 230, 138, 0.12);
      border-color: rgba(251, 191, 36, 0.5);
      color: #f6e6b2;
      box-shadow: inset 0 0 0 1px rgba(250, 200, 88, 0.3);
    }
    .post-body .post-warning summary {
      list-style: none;
      cursor: pointer;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 1rem 0;
      color: inherit;
    }
    .post-body .post-warning summary::-webkit-details-marker {
      display: none;
    }
    .post-body .post-warning summary::before {
      content: '‚ö†Ô∏è';
      font-size: 1rem;
    }
    .post-body .post-warning[open] {
      padding-bottom: 1.25rem;
    }
    .post-body .post-warning p:last-child {
      margin-bottom: 0;
    }
    .post-body ul,
    .post-body ol {
      margin: 1.4rem 0 1.4rem 1.4rem;
      padding: 0;
    }
    .post-body li {
      margin-bottom: 0.8rem;
    }
    .post-body a {
      color: var(--accent);
      text-decoration: none;
      border-bottom: 1px solid rgba(96, 165, 250, 0.35);
      transition: color 0.2s ease, border-bottom 0.2s ease;
    }
    .post-body a:hover {
      color: var(--accent-strong);
      border-bottom-color: var(--accent-strong);
    }
    .post-body blockquote {
      margin: 2rem 0;
      padding: 1.5rem 1.75rem;
      border-left: 4px solid var(--accent);
      border-radius: 0 18px 18px 0;
      background: rgba(37, 99, 235, 0.12);
      color: var(--text-primary);
    }
    .post-body code {
      background: var(--code-inline-bg);
      color: var(--code-text);
      padding: 0.2rem 0.45rem;
      border-radius: 6px;
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      font-size: 0.9rem;
    }
    .post-body pre code {
      background: transparent;
      padding: 0;
      display: block;
      font-size: inherit;
      line-height: inherit;
    }
    .hljs {
      color: #e2e8f0;
      background: transparent;
    }
    .hljs-comment,
    .hljs-quote {
      color: #7dd79d;
      font-style: italic;
    }
    .hljs-keyword,
    .hljs-selector-tag,
    .hljs-literal,
    .hljs-name,
    .hljs-strong,
    .hljs-built_in {
      color: #7dd3fc;
      font-weight: 600;
    }
    .hljs-title,
    .hljs-section,
    .hljs-function,
    .hljs-meta .hljs-keyword {
      color: #38bdf8;
      font-weight: 600;
    }
    .hljs-string,
    .hljs-doctag,
    .hljs-addition,
    .hljs-attribute,
    .hljs-template-tag,
    .hljs-template-variable {
      color: #facc15;
    }
    .hljs-number,
    .hljs-symbol,
    .hljs-bullet,
    .hljs-link,
    .hljs-meta,
    .hljs-type {
      color: #f472b6;
    }
    .hljs-variable,
    .hljs-params {
      color: #cbd5f5;
    }
    .post-body pre {
      background: var(--code-block-bg);
      color: var(--code-text);
      padding: 1.2rem 1.4rem;
      padding-right: 3.6rem;
      border-radius: 18px;
      overflow-x: auto;
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      font-size: 0.95rem;
      box-shadow: var(--code-shadow);
      border: 1px solid var(--code-border);
      margin: 2rem 0;
      position: relative;
    }
    .code-copy-btn {
      position: absolute;
      top: 0.75rem;
      right: 0.75rem;
      background: rgba(15, 23, 42, 0.8);
      color: #e2e8f0;
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 999px;
      padding: 0.25rem 0.85rem;
      font-size: 0.85rem;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
    }
    .code-copy-btn:hover {
      background: rgba(96, 165, 250, 0.85);
      color: #ffffff;
      border-color: transparent;
      transform: translateY(-1px);
    }
    .code-copy-btn--copied {
      background: rgba(34, 197, 94, 0.85);
      color: #ffffff;
      border-color: transparent;
    }
    .code-copy-btn__icon {
      font-size: 0.95rem;
    }
    .code-copy-btn__text {
      display: inline-block;
    }
    body[data-theme="light"] .code-copy-btn {
      background: rgba(248, 250, 252, 0.85);
      color: #0f172a;
      border-color: rgba(148, 163, 184, 0.4);
    }
    body[data-theme="light"] .code-copy-btn--copied {
      background: rgba(34, 197, 94, 0.92);
      color: #ffffff;
    }
    .post-body img {
      max-width: 100%;
      border-radius: 18px;
      margin: 2.2rem 0;
      box-shadow: 0 24px 45px -28px rgba(15, 23, 42, 0.55);
    }
    .post-body .table-wrapper {
      margin: 2rem 0;
      border-radius: 18px;
      border: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.55);
      box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.12);
      position: relative;
      overflow: hidden;
    }
    .post-body .table-wrapper__scroll {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }
    .post-body .table-wrapper__scroll::-webkit-scrollbar {
      height: 10px;
    }
    .post-body .table-wrapper__scroll::-webkit-scrollbar-thumb {
      background: rgba(96, 165, 250, 0.4);
      border-radius: 999px;
    }
    .post-body .table-wrapper table {
      width: 100%;
      border-collapse: collapse;
      background: transparent;
    }
    .post-body .table-wrapper[data-table-size="medium"] table {
      min-width: 720px;
    }
    .post-body .table-wrapper[data-table-size="wide"] table {
      min-width: 960px;
    }
    .post-body .table-wrapper thead th {
      background: rgba(96, 165, 250, 0.12);
      color: var(--text-primary);
      font-weight: 600;
    }
    .post-body .table-wrapper th,
    .post-body .table-wrapper td {
      padding: 0.9rem 1rem;
      text-align: left;
      border-bottom: 1px solid rgba(148, 163, 184, 0.18);
      white-space: nowrap;
    }
    .post-body .table-wrapper td {
      white-space: normal;
    }
    .post-body .table-wrapper tr:last-child td {
      border-bottom: none;
    }
    .post-body .table-wrapper__expand {
      position: absolute;
      top: 0.75rem;
      right: 0.75rem;
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.3);
      color: var(--accent);
      border-radius: 999px;
      padding: 0.35rem 0.9rem;
      font-size: 0.85rem;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
      z-index: 2;
    }
    .post-body .table-wrapper__expand:hover {
      background: rgba(37, 99, 235, 0.35);
      color: #ffffff;
      transform: translateY(-1px);
      border-color: transparent;
    }
    .table-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.85);
      backdrop-filter: blur(6px);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      z-index: 999;
    }
    .table-overlay--visible {
      display: flex;
    }
    .table-overlay__content {
      background: var(--bg-card-strong);
      border: 1px solid var(--border);
      border-radius: 24px;
      max-width: min(1080px, 92vw);
      max-height: 85vh;
      width: 100%;
      box-shadow: 0 32px 80px -40px rgba(15, 23, 42, 0.9);
      position: relative;
      overflow: hidden;
    }
    .table-overlay__close {
      position: absolute;
      top: 0.85rem;
      right: 0.85rem;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.35);
      color: var(--text-primary);
      border-radius: 999px;
      padding: 0.4rem 1rem;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease;
    }
    .table-overlay__close:hover {
      background: rgba(37, 99, 235, 0.4);
      color: #ffffff;
      border-color: transparent;
    }
    .table-overlay__scroll {
      overflow: auto;
      max-height: 85vh;
      padding: 2.5rem 2rem 2rem;
    }
    .table-overlay__scroll table {
      width: 100%;
      border-collapse: collapse;
      background: transparent;
    }
    .table-overlay__scroll table[data-table-size="medium"] {
      min-width: 720px;
    }
    .table-overlay__scroll table[data-table-size="wide"] {
      min-width: 960px;
    }
    .table-overlay__scroll thead th {
      background: rgba(96, 165, 250, 0.12);
      color: var(--text-primary);
      font-weight: 600;
    }
    .table-overlay__scroll th,
    .table-overlay__scroll td {
      padding: 0.9rem 1rem;
      text-align: left;
      border-bottom: 1px solid rgba(148, 163, 184, 0.18);
      white-space: nowrap;
    }
    .table-overlay__scroll td {
      white-space: normal;
    }
    .table-overlay__scroll tr:last-child td {
      border-bottom: none;
    }
    body[data-theme="light"] .post-body .table-wrapper {
      background: rgba(255, 255, 255, 0.96);
      box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.16);
    }
    body[data-theme="light"] .post-body .table-wrapper__expand {
      background: rgba(248, 250, 252, 0.9);
    }
    body[data-theme="light"] .table-overlay {
      background: rgba(15, 23, 42, 0.25);
    }
    body[data-theme="light"] .table-overlay__content {
      background: rgba(255, 255, 255, 0.98);
    }
    body.no-scroll {
      overflow: hidden;
    }
    footer {
      margin-top: 4rem;
      padding: 2rem 0;
      text-align: center;
      color: var(--text-muted);
      font-size: 0.92rem;
      border-top: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.35);
    }
    body[data-theme="light"] footer {
      background: rgba(255, 255, 255, 0.72);
    }
    @media (max-width: 1024px) {
      .site-header__inner {
        padding: 1rem clamp(1.25rem, 4vw, 2rem);
      }
      main.page {
        padding: 2.75rem clamp(1.25rem, 4vw, 2rem) 4rem;
      }
      .post-layout {
        grid-template-columns: minmax(0, 1fr);
      }
      .post-toc {
        position: sticky;
        top: 88px;
        z-index: 6;
        max-height: calc(100vh - 140px);
        margin-bottom: 2rem;
        padding: 1.1rem 1.25rem 1.35rem;
      }
      .post-toc__toggle {
        display: inline-flex;
      }
      .post-toc__content {
        max-height: none;
        margin-top: 0.4rem;
        overflow: visible;
      }
    }
    @media (max-width: 720px) {
      .post-hero {
        padding: 2.1rem 1.65rem;
      }
      .post-body {
        padding: 1.9rem 1.5rem;
      }
      .site-header__inner {
        flex-direction: column;
        align-items: stretch;
        gap: 1rem;
      }
      .site-header__left {
        justify-content: space-between;
      }
      .header-controls {
        align-self: flex-end;
      }
      .post-hero__title {
        font-size: clamp(2rem, 6vw, 2.6rem);
      }
      .post-body .table-wrapper {
        margin: 1.6rem 0;
      }
      .post-body .table-wrapper__expand {
        top: 0.6rem;
        right: 0.6rem;
        font-size: 0.78rem;
        padding: 0.25rem 0.75rem;
      }
      .table-overlay__scroll {
        padding: 1.8rem 1.25rem 1.5rem;
      }
    }
  </style>
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      },
    };
  </script>
  <script id="mathjax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body data-theme="dark">
  <header class="site-header">
    <div class="site-header__inner">
      <div class="site-header__left">
        <a class="logo" href="../../../index.html">
          <img src="../../../Assets/Logo.png" alt="Mirko Calcaterra logo" class="logo-img">
          <span class="logo-text">Mirko Calcaterra</span>
        </a>
        <nav class="site-nav">
          <a href="../../../index.html" data-it="Home" data-en="Home">Home</a>
          <a href="../../../blog/index.html" data-it="Blog" data-en="Blog">Blog</a>
        </nav>
      </div>
      <div class="header-controls">
        <button class="lang-btn" type="button">EN</button>
        <button class="theme-toggle" type="button" aria-label="Toggle theme">
          <span class="theme-thumb">‚òÄÔ∏è</span>
        </button>
      </div>
    </div>
  </header>
  <main class="page">
    <article class="post">
      <section class="post-hero">
        <div class="post-hero__icon">üß™</div>
        <span class="post-hero__category">Programmazione</span>
        <h1 class="post-hero__title">Elixir Cheatsheet</h1>
        <div class="post-hero__meta">
          <span>üìÖ 23 gennaio 2026</span>
          <span>‚è±Ô∏è 12 min</span>
        </div>
      </section>
      <section class="post-layout">
        <aside class="post-toc" data-collapsed="false">
        <div class="post-toc__header">
          <div class="post-toc__title" data-it="Indice" data-en="Table of contents">Indice</div>
          <button class="post-toc__toggle" type="button" aria-expanded="true" aria-label="Nascondi indice">
            <span class="post-toc__toggle-text">Indice</span>
            <span class="post-toc__toggle-icon" aria-hidden="true">‚ñæ</span>
          </button>
        </div>
        <div class="post-toc__content">
          <ul class="post-toc__list">
    <li class="post-toc__item" data-depth="0">
          <a class="post-toc__link" href="#1-hello-world">
            <span class="post-toc__number">1</span>
            <span class="post-toc__text">1. Hello World</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="0">
          <a class="post-toc__link" href="#2-atomi-e-stringhe-le-basi">
            <span class="post-toc__number">2</span>
            <span class="post-toc__text">2. Atomi e Stringhe: le basi</span>
          </a>
          <ul class="post-toc__list post-toc__sublist">
    <li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#atomi">
            <span class="post-toc__number">2.1</span>
            <span class="post-toc__text">Atomi</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#stringhe">
            <span class="post-toc__number">2.2</span>
            <span class="post-toc__text">Stringhe</span>
          </a>
          
        </li>
  </ul>
        </li><li class="post-toc__item" data-depth="0">
          <a class="post-toc__link" href="#3-collezioni-liste-vs-tuple">
            <span class="post-toc__number">3</span>
            <span class="post-toc__text">3. Collezioni: Liste vs Tuple</span>
          </a>
          <ul class="post-toc__list post-toc__sublist">
    <li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#liste-o-linked-lists">
            <span class="post-toc__number">3.1</span>
            <span class="post-toc__text">Liste o linked lists</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#tuple">
            <span class="post-toc__number">3.2</span>
            <span class="post-toc__text">Tuple</span>
          </a>
          
        </li>
  </ul>
        </li><li class="post-toc__item" data-depth="0">
          <a class="post-toc__link" href="#4-mappe-e-keyword-lists">
            <span class="post-toc__number">4</span>
            <span class="post-toc__text">4. Mappe e Keyword Lists</span>
          </a>
          <ul class="post-toc__list post-toc__sublist">
    <li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#mappe">
            <span class="post-toc__number">4.1</span>
            <span class="post-toc__text">Mappe (%{})</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#keyword-lists">
            <span class="post-toc__number">4.2</span>
            <span class="post-toc__text">Keyword Lists</span>
          </a>
          
        </li>
  </ul>
        </li><li class="post-toc__item" data-depth="0">
          <a class="post-toc__link" href="#5-pattern-matching-la-magia-delloperatore">
            <span class="post-toc__number">5</span>
            <span class="post-toc__text">5. Pattern Matching: La Magia dell&#39;Operatore =</span>
          </a>
          <ul class="post-toc__list post-toc__sublist">
    <li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#come-funziona">
            <span class="post-toc__number">5.1</span>
            <span class="post-toc__text">Come funziona?</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#pattern-matching-con-tuple">
            <span class="post-toc__number">5.2</span>
            <span class="post-toc__text">Pattern Matching con tuple</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#pattern-matching-con-liste">
            <span class="post-toc__number">5.3</span>
            <span class="post-toc__text">Pattern Matching con liste</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#pattern-matching-con-mappe">
            <span class="post-toc__number">5.4</span>
            <span class="post-toc__text">Pattern Matching con mappe</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#pattern-matching-con-le-funzioni">
            <span class="post-toc__number">5.5</span>
            <span class="post-toc__text">Pattern Matching con le funzioni</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#il-pin-operator">
            <span class="post-toc__number">5.6</span>
            <span class="post-toc__text">Il pin operator (^)</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#lunderscore-il-jolly">
            <span class="post-toc__number">5.7</span>
            <span class="post-toc__text">L&#39;underscore: il jolly</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#pattern-matching-ovunque">
            <span class="post-toc__number">5.8</span>
            <span class="post-toc__text">Pattern Matching ovunque!</span>
          </a>
          
        </li>
  </ul>
        </li><li class="post-toc__item" data-depth="0">
          <a class="post-toc__link" href="#6-funzioni-e-moduli">
            <span class="post-toc__number">6</span>
            <span class="post-toc__text">6. Funzioni e moduli</span>
          </a>
          <ul class="post-toc__list post-toc__sublist">
    <li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#funzioni-con-nome">
            <span class="post-toc__number">6.1</span>
            <span class="post-toc__text">Funzioni con nome</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#pattern-matching-nelle-funzioni">
            <span class="post-toc__number">6.2</span>
            <span class="post-toc__text">Pattern Matching nelle funzioni</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#ricorsione-con-pattern-matching">
            <span class="post-toc__number">6.3</span>
            <span class="post-toc__text">Ricorsione con Pattern Matching</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#guard-clauses">
            <span class="post-toc__number">6.4</span>
            <span class="post-toc__text">Guard Clauses</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#funzioni-anonime">
            <span class="post-toc__number">6.5</span>
            <span class="post-toc__text">Funzioni anonime</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#sintassi-shorthand-con">
            <span class="post-toc__number">6.6</span>
            <span class="post-toc__text">Sintassi shorthand con &amp;</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#argomenti-di-default">
            <span class="post-toc__number">6.7</span>
            <span class="post-toc__text">Argomenti di default</span>
          </a>
          
        </li>
  </ul>
        </li><li class="post-toc__item" data-depth="0">
          <a class="post-toc__link" href="#7-loperatore-pipe-scrivere-codice-leggibile">
            <span class="post-toc__number">7</span>
            <span class="post-toc__text">7. L&#39;Operatore Pipe (|&gt;): Scrivere Codice Leggibile</span>
          </a>
          <ul class="post-toc__list post-toc__sublist">
    <li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#perch-esiste">
            <span class="post-toc__number">7.1</span>
            <span class="post-toc__text">Perch√© esiste?</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#come-funziona-1">
            <span class="post-toc__number">7.2</span>
            <span class="post-toc__text">Come funziona?</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#esempi">
            <span class="post-toc__number">7.3</span>
            <span class="post-toc__text">Esempi</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#pipe-con-funzioni-multi-argomento">
            <span class="post-toc__number">7.4</span>
            <span class="post-toc__text">Pipe con funzioni multi-argomento</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#debug-con-ioinspect">
            <span class="post-toc__number">7.5</span>
            <span class="post-toc__text">Debug con `IO.inspect`</span>
          </a>
          
        </li>
  </ul>
        </li><li class="post-toc__item" data-depth="0">
          <a class="post-toc__link" href="#8-control-flow-if-case-cond">
            <span class="post-toc__number">8</span>
            <span class="post-toc__text">8. Control Flow: if, case, cond</span>
          </a>
          <ul class="post-toc__list post-toc__sublist">
    <li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#ifunless">
            <span class="post-toc__number">8.1</span>
            <span class="post-toc__text">if/unless</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#case">
            <span class="post-toc__number">8.2</span>
            <span class="post-toc__text">case</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#cond">
            <span class="post-toc__number">8.3</span>
            <span class="post-toc__text">cond</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#with">
            <span class="post-toc__number">8.4</span>
            <span class="post-toc__text">with</span>
          </a>
          
        </li>
  </ul>
        </li><li class="post-toc__item" data-depth="0">
          <a class="post-toc__link" href="#9-concorrenza-processi-e-messaggi">
            <span class="post-toc__number">9</span>
            <span class="post-toc__text">9. Concorrenza: processi e messaggi</span>
          </a>
          <ul class="post-toc__list post-toc__sublist">
    <li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#creare-un-processo">
            <span class="post-toc__number">9.1</span>
            <span class="post-toc__text">Creare un processo</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#task-processi-con-stile">
            <span class="post-toc__number">9.2</span>
            <span class="post-toc__text">Task: processi con stile</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#agent-stato-condiviso">
            <span class="post-toc__number">9.3</span>
            <span class="post-toc__text">Agent: stato condiviso</span>
          </a>
          
        </li>
  </ul>
        </li><li class="post-toc__item" data-depth="0">
          <a class="post-toc__link" href="#10-enum-e-stream-come-lavorare-con-le-collezioni">
            <span class="post-toc__number">10</span>
            <span class="post-toc__text">10. Enum e Stream: come lavorare con le collezioni</span>
          </a>
          <ul class="post-toc__list post-toc__sublist">
    <li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#stream-lazy-evaluation">
            <span class="post-toc__number">10.1</span>
            <span class="post-toc__text">Stream: lazy evaluation</span>
          </a>
          
        </li>
  </ul>
        </li><li class="post-toc__item" data-depth="0">
          <a class="post-toc__link" href="#conclusione">
            <span class="post-toc__number">11</span>
            <span class="post-toc__text">Conclusione</span>
          </a>
          <ul class="post-toc__list post-toc__sublist">
    <li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#perch-scegliere-elixir">
            <span class="post-toc__number">11.1</span>
            <span class="post-toc__text">Perch√© scegliere Elixir?</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#prossimi-passi">
            <span class="post-toc__number">11.2</span>
            <span class="post-toc__text">Prossimi passi</span>
          </a>
          
        </li><li class="post-toc__item" data-depth="1">
          <a class="post-toc__link" href="#risorse-utili">
            <span class="post-toc__number">11.3</span>
            <span class="post-toc__text">Risorse utili</span>
          </a>
          
        </li>
  </ul>
        </li>
  </ul>
        </div>
      </aside>
        <div class="post-body">
          <p>Se stai leggendo questo articolo, probabilmente hai sentito parlare di Elixir, quel linguaggio che unisce la sintassi elegante di Ruby con la potenza bruta e la concorrenza (questo termine in italiano √® veramente cacofonico) di Erlang. O forse sei stato solo incuriosito dal titolo dell&#39;articolo. In ogni caso, ora lo vediamo insieme.</p>
<p>Elixir non √® solo un altro linguaggio di scripting; √® un modo diverso di pensare. Gira sulla <strong>BEAM</strong> (la macchina virtuale di Erlang), il che significa che √® costruito per scalare e scrivere codice come si deve, gestendo milioni di processi concorrenti con una facilit√† disarmante.</p>
<p>In questo articolo, esploreremo i concetti fondamentali di Elixir, dandoti una base solida con esempi pratici e qualche trucco del mestiere che ti far√† risparmiare ore di debug.</p>
<h2 id="1-hello-world">1. Hello World</h2>
<p>Prima di tuffarci nei dettagli, iniziamo dal tradizionale step che vi permette di dire che sapete un linguaggio: come stampare il classico &quot;Hello World&quot;.</p>
<p>In Elixir, il modulo <code>IO</code> gestisce l&#39;Input e l&#39;Output.</p>
<pre><code class="hljs language-elixir"><span class="hljs-title class_">IO</span>.puts <span class="hljs-string">&quot;Hello World!&quot;</span>
<span class="hljs-comment"># Stampa: Hello World!</span>
<span class="hljs-comment"># Ritorna: :ok</span></code></pre><p>Semplice, no? Ma c&#39;√® un dettaglio interessante: <code>IO.puts</code> restituisce sempre l&#39;atomo <code>:ok</code> dopo aver stampato.</p>
<blockquote>
<p>üí° <strong>Pro Tip</strong>: <code>IO.puts</code> √® ottimo per mostrare testo agli umani, ma se provi a stampare strutture complesse (come Mappe o Liste), potresti ottenere risultati illeggibili. Per il debug, usa sempre <code>IO.inspect(dato)</code>. La magia di <code>IO.inspect</code> √® che stampa il dato e lo restituisce intatto, permettendoti di inserirlo in mezzo al codice senza romperlo.</p>
</blockquote>
<h2 id="2-atomi-e-stringhe-le-basi">2. Atomi e Stringhe: le basi</h2>
<p>In Elixir, come anche in chimica, tutto si basa sugli atomi. Ma cosa sono esattamente?</p>
<blockquote>
<p><strong>Un atomo √® una costante il cui valore √® il suo stesso nome.</strong></p>
</blockquote>
<p>Pensa a loro come a delle etichette super efficienti o agli enum di altri linguaggi, ma pi√π flessibili.</p>
<h3 id="atomi">Atomi</h3>
<pre><code class="hljs language-elixir"><span class="hljs-symbol">:successo</span>
<span class="hljs-symbol">:errore</span>
<span class="hljs-symbol">:ok</span>
<span class="hljs-symbol">:not_found</span></code></pre><p>A cosa servono? A comunicare stati o intenzioni senza usare stringhe pesanti.</p>
<blockquote>
<p><strong>Esempio</strong>: Invece di restituire la stringa <code>&quot;operazione_fallita&quot;</code>, una funzione ti risponde con <code>:error</code>. √à un&#39;etichetta fissa e inequivocabile.</p>
</blockquote>
<h3 id="stringhe">Stringhe</h3>
<p>Le stringhe in Elixir sono codificate in UTF-8. Funzionano come ti aspetti, ma con il supporto completo per l&#39;interpolazione.</p>
<pre><code class="hljs language-elixir"><span class="hljs-comment"># Stringhe e variabili</span>
name = <span class="hljs-string">&quot;Dev&quot;</span>
<span class="hljs-string">&quot;Ciao <span class="hljs-subst">#{name}</span>!&quot;</span> <span class="hljs-comment"># =&gt; &quot;Ciao Dev!&quot;</span>

<span class="hljs-comment"># Concatenazione</span>
<span class="hljs-string">&quot;Hello &quot;</span> &lt;&gt; <span class="hljs-string">&quot;World&quot;</span> <span class="hljs-comment"># =&gt; &quot;Hello World&quot;</span>

<span class="hljs-comment"># Multilinea</span>
<span class="hljs-string">&quot;&quot;&quot;
Questa √® una stringa
su pi√π righe
&quot;&quot;&quot;</span></code></pre><blockquote>
<p>üí° <strong>Pro Tip</strong>: Gli atomi sono gestiti in una tabella interna della VM e non vengono mai deallocati dal Garbage Collector. Sono velocissimi per i confronti, ma <strong>non generarli dinamicamente</strong> (ad esempio convertendo input utente in atomi) all&#39;infinito, o rischierai di esaurire la memoria della VM (Atom table limit).</p>
</blockquote>
<h2 id="3-collezioni-liste-vs-tuple">3. Collezioni: Liste vs Tuple</h2>
<p>Qui √® dove molti inciampano venendo da linguaggi imperativi. In Elixir abbiamo due tipi principali di collezioni:</p>
<ul>
<li><p><strong>Liste (<code>[]</code>)</strong>: Sono Linked Lists (liste collegate). Immaginale come una caccia al tesoro: ogni elemento contiene il suo valore e un bigliettino che dice &quot;il prossimo elemento √® laggi√π&quot;. Da una parte aggiungere un elemento in testa √® istantaneo (basta creare un nuovo bigliettino che punta alla vecchia lista), dall&#39;altra per trovare l&#39;elemento numero 1000, devi leggere tutti i 999 bigliettini precedenti.</p>
</li>
<li><p><strong>Tuple (<code>{}</code>)</strong>: Sono blocchi di memoria contigui, simili agli array di C. Immaginale come uno scaffale fisso dove ogni cosa ha il suo posto numerato. Da una parte possono accedere a qualsiasi elemento √® velocissimo, non importa dove si trovi. Dall&#39;altra modificarle √® costoso (in termini di memoria) perch√© bisogna copiare l&#39;intero scaffale in un nuovo spazio.</p>
</li>
</ul>
<p>Sembrano simili, ma le prestazioni sono <strong>opposte</strong>.</p>
<h3 id="liste-o-linked-lists">Liste o linked lists</h3>
<pre><code class="hljs language-elixir"><span class="hljs-comment"># Creare una lista</span>
lista = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]

<span class="hljs-comment"># Accedere agli elementi</span>
<span class="hljs-title class_">List</span>.first(lista) <span class="hljs-comment"># =&gt; 1</span>
<span class="hljs-title class_">List</span>.last(lista)  <span class="hljs-comment"># =&gt; 3</span>

<span class="hljs-comment"># Aggiungere in testa (VELOCE!)</span>
[<span class="hljs-number">0</span> | lista] <span class="hljs-comment"># =&gt; [0, 1, 2, 3]</span>

<span class="hljs-comment"># Aggiungere in coda (LENTO!)</span>
lista ++ [<span class="hljs-number">4</span>] <span class="hljs-comment"># =&gt; [1, 2, 3, 4]</span>

<span class="hljs-comment"># Concatenare liste</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] ++ [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>] <span class="hljs-comment"># =&gt; [1, 2, 3, 4]</span>

<span class="hljs-comment"># Lunghezza</span>
length(lista) <span class="hljs-comment"># =&gt; 3</span></code></pre><h3 id="tuple">Tuple</h3>
<pre><code class="hljs language-elixir"><span class="hljs-comment"># Creare una tupla</span>
tupla = {<span class="hljs-symbol">:ok</span>, <span class="hljs-string">&quot;Tutto bene&quot;</span>}

<span class="hljs-comment"># Accedere agli elementi (per indice)</span>
elem(tupla, <span class="hljs-number">0</span>) <span class="hljs-comment"># =&gt; :ok</span>
elem(tupla, <span class="hljs-number">1</span>) <span class="hljs-comment"># =&gt; &quot;Tutto bene&quot;</span>

<span class="hljs-comment"># Dimensione della tupla</span>
tuple_size(tupla) <span class="hljs-comment"># =&gt; 2</span>

<span class="hljs-comment"># Aggiornare una tupla (crea una nuova tupla)</span>
put_elem(tupla, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Modificato&quot;</span>)
<span class="hljs-comment"># =&gt; {:ok, &quot;Modificato&quot;}</span>

<span class="hljs-comment"># Uso comune: risultati di funzioni</span>
{<span class="hljs-symbol">:ok</span>, <span class="hljs-string">&quot;Successo&quot;</span>}
{<span class="hljs-symbol">:error</span>, <span class="hljs-string">&quot;Qualcosa √® andato storto&quot;</span>}</code></pre><blockquote>
<p>üí° <strong>Pro Tip</strong>: Usa le <strong>Liste</strong> quando devi scorrere dati o aggiungere elementi in testa dinamicamente. Usa le <strong>Tuple</strong> quando sai esattamente quanti elementi hai (come restituire <code>{:ok, result}</code> da una funzione). Ricorda: aggiungere un elemento in fondo a una lista √® un&#39;operazione lenta <strong>O(n)</strong>, mentre aggiungerlo in testa √® istantaneo <strong>O(1)</strong>.</p>
</blockquote>
<h2 id="4-mappe-e-keyword-lists">4. Mappe e Keyword Lists</h2>
<p>Hai bisogno di strutture chiave-valore? Hai due strade principali:</p>
<h3 id="mappe">Mappe (%{})</h3>
<p>Le Mappe sono il &quot;go-to&quot; per strutture dati generiche. Offrono accesso rapido e una sintassi oggettivamente comoda.</p>
<pre><code class="hljs language-elixir"><span class="hljs-comment"># Creare una mappa con chiavi atomo</span>
user = %{<span class="hljs-symbol">name:</span> <span class="hljs-string">&quot;Lucia&quot;</span>, <span class="hljs-symbol">age:</span> <span class="hljs-number">23</span>}

<span class="hljs-comment"># Accedere ai valori (due modi)</span>
user.name    <span class="hljs-comment"># =&gt; &quot;Lucia&quot; (solo se la chiave √® un atomo)</span>
user[<span class="hljs-symbol">:age</span>]   <span class="hljs-comment"># =&gt; 23</span>
user[<span class="hljs-symbol">:email</span>] <span class="hljs-comment"># =&gt; nil (chiave non esiste)</span>

<span class="hljs-comment"># Mappa con chiavi stringa</span>
config = %{<span class="hljs-string">&quot;host&quot;</span> =&gt; <span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-string">&quot;port&quot;</span> =&gt; <span class="hljs-number">8080</span>}
config[<span class="hljs-string">&quot;host&quot;</span>] <span class="hljs-comment"># =&gt; &quot;localhost&quot;</span>

<span class="hljs-comment"># Aggiornare un valore esistente</span>
%{user | <span class="hljs-symbol">age:</span> <span class="hljs-number">24</span>} <span class="hljs-comment"># =&gt; %{name: &quot;Lucia&quot;, age: 24}</span>

<span class="hljs-comment"># Aggiungere nuove chiavi</span>
<span class="hljs-title class_">Map</span>.put(user, <span class="hljs-symbol">:email</span>, <span class="hljs-string">&quot;lucia@example.com&quot;</span>)
<span class="hljs-comment"># =&gt; %{name: &quot;Lucia&quot;, age: 23, email: &quot;lucia@example.com&quot;}</span>

<span class="hljs-comment"># Rimuovere una chiave</span>
<span class="hljs-title class_">Map</span>.delete(user, <span class="hljs-symbol">:age</span>)
<span class="hljs-comment"># =&gt; %{name: &quot;Lucia&quot;}</span>

<span class="hljs-comment"># Verificare se una chiave esiste</span>
<span class="hljs-title class_">Map</span>.has_key?(user, <span class="hljs-symbol">:name</span>) <span class="hljs-comment"># =&gt; true</span></code></pre><h3 id="keyword-lists">Keyword Lists</h3>
<p>Sono liste speciali di tuple usate principalmente per passare opzioni alle funzioni. La differenza con le mappe? L&#39;ordine √® garantito e le chiavi possono ripetersi.</p>
<pre><code class="hljs language-elixir"><span class="hljs-comment"># Keyword List</span>
options = [<span class="hljs-symbol">debug:</span> <span class="hljs-literal">true</span>, <span class="hljs-symbol">active:</span> <span class="hljs-literal">false</span>]
<span class="hljs-comment"># √à zucchero sintattico per: [{:debug, true}, {:active, false}]</span>

<span class="hljs-comment"># Accesso</span>
options[<span class="hljs-symbol">:debug</span>] <span class="hljs-comment"># =&gt; true</span>

<span class="hljs-comment"># Chiavi duplicate (l&#x27;accesso prende il primo)</span>
options = [<span class="hljs-symbol">debug:</span> <span class="hljs-literal">true</span>, <span class="hljs-symbol">active:</span> <span class="hljs-literal">false</span>, <span class="hljs-symbol">debug:</span> <span class="hljs-literal">false</span>]
options[<span class="hljs-symbol">:debug</span>] <span class="hljs-comment"># =&gt; true (primo valore)</span>

<span class="hljs-comment"># Uso comune: opzioni di funzione</span>
<span class="hljs-title class_">String</span>.split(<span class="hljs-string">&quot;a,b,c&quot;</span>, <span class="hljs-string">&quot;,&quot;</span>, <span class="hljs-symbol">trim:</span> <span class="hljs-literal">true</span>)
<span class="hljs-title class_">Enum</span>.map([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-keyword">fn</span> x -&gt; x * <span class="hljs-number">2</span> <span class="hljs-keyword">end</span>)</code></pre><blockquote>
<p>üí° <strong>Pro Tip</strong>: Se cerchi una chiave che non esiste con la sintassi <code>map.key</code>, otterrai un <strong>errore</strong> (KeyError); se usi <code>map[:key]</code>, otterrai <code>nil</code>. Usa la prima quando sei sicuro che la chiave esiste, la seconda quando vuoi gestire l&#39;assenza del valore.</p>
</blockquote>
<h2 id="5-pattern-matching-la-magia-delloperatore">5. Pattern Matching: La Magia dell&#39;Operatore =</h2>
<p>Ecco, finalmente siamo arrivati al motivo per cui ho iniziato ad apprezzare Elixir. In Elixir, il simbolo <code>=</code> <strong>non √® un&#39;assegnazione</strong> nel senso tradizionale. √à un <strong>match operator</strong>: Elixir prova a far combaciare (match) il lato sinistro con il destro. Se ci riesce, lega le variabili; se no, lancia un errore.</p>
<p><strong>√à la feature pi√π potente del linguaggio</strong> e cambia completamente il modo in cui scrivi codice.</p>
<h3 id="come-funziona">Come funziona?</h3>
<p>Pensa a <code>=</code> come a un&#39;equazione matematica. Elixir cerca di rendere veri entrambi i lati:</p>
<pre><code class="hljs language-elixir"><span class="hljs-comment"># &quot;x deve essere uguale a 1&quot;</span>
x = <span class="hljs-number">1</span>
<span class="hljs-comment"># Elixir lega x al valore 1</span>

<span class="hljs-comment"># &quot;1 deve essere uguale a 1&quot;</span>
<span class="hljs-number">1</span> = x
<span class="hljs-comment"># OK! Matcha perch√© x vale 1</span>

<span class="hljs-comment"># &quot;2 deve essere uguale a 1&quot;</span>
<span class="hljs-number">2</span> = x
<span class="hljs-comment"># ** (MatchError) no match of right hand side value: 1</span></code></pre><h3 id="pattern-matching-con-tuple">Pattern Matching con tuple</h3>
<p>Ora che conosci le tuple, esatttamente come le abbiamo costruite, ora vediamo come destrutturarle:</p>
<pre><code class="hljs language-elixir"><span class="hljs-comment"># Destrutturare una tupla</span>
{a, b} = {<span class="hljs-number">10</span>, <span class="hljs-number">20</span>}
<span class="hljs-comment"># a =&gt; 10, b =&gt; 20</span>

<span class="hljs-comment"># Uso pratico: gestire risultati di funzioni</span>
{<span class="hljs-symbol">:ok</span>, result} = {<span class="hljs-symbol">:ok</span>, <span class="hljs-string">&quot;Operazione riuscita&quot;</span>}
<span class="hljs-comment"># result =&gt; &quot;Operazione riuscita&quot;</span>

<span class="hljs-comment"># Se il pattern non matcha, errore!</span>
{<span class="hljs-symbol">:ok</span>, result} = {<span class="hljs-symbol">:error</span>, <span class="hljs-string">&quot;Qualcosa √® andato storto&quot;</span>}
<span class="hljs-comment"># ** (MatchError) no match of right hand side value: {:error, &quot;Qualcosa √® andato storto&quot;}</span>

<span class="hljs-comment"># Ignorare valori che non ci interessano</span>
{<span class="hljs-symbol">:ok</span>, _} = {<span class="hljs-symbol">:ok</span>, <span class="hljs-string">&quot;Non mi interessa il contenuto&quot;</span>}
<span class="hljs-comment"># OK! L&#x27;underscore matcha qualsiasi cosa</span>

<span class="hljs-comment"># Esempio real-world: File.read</span>
{<span class="hljs-symbol">:ok</span>, contenuto} = <span class="hljs-title class_">File</span>.read(<span class="hljs-string">&quot;config.txt&quot;</span>)
<span class="hljs-comment"># Se il file esiste, contenuto avr√† il testo</span>
<span class="hljs-comment"># Se no, MatchError (crash diciamo &quot;intenzionale&quot;)</span></code></pre><h3 id="pattern-matching-con-liste">Pattern Matching con liste</h3>
<p>Le liste assumono tutto un altro fascino con il pattern matching:</p>
<pre><code class="hljs language-elixir"><span class="hljs-comment"># Destrutturare head (testa) e tail (coda)</span>
[head | tail] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
<span class="hljs-comment"># head =&gt; 1</span>
<span class="hljs-comment"># tail =&gt; [2, 3, 4, 5]</span>

<span class="hljs-comment"># Prendere i primi due elementi</span>
[first, second | rest] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
<span class="hljs-comment"># first =&gt; 1, second =&gt; 2, rest =&gt; [3, 4, 5]</span>

<span class="hljs-comment"># Pattern matching esatto</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
<span class="hljs-comment"># OK!</span>

<span class="hljs-comment"># Pattern matching con valori misti</span>
[<span class="hljs-number">1</span>, x, <span class="hljs-number">3</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">42</span>, <span class="hljs-number">3</span>]
<span class="hljs-comment"># x =&gt; 42</span>

<span class="hljs-comment"># Lista vuota</span>
[] = []
<span class="hljs-comment"># OK!</span>

<span class="hljs-comment"># Questo fallirebbe</span>
[a, b] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
<span class="hljs-comment"># ** (MatchError) - il pattern richiede esattamente 2 elementi</span></code></pre><h3 id="pattern-matching-con-mappe">Pattern Matching con mappe</h3>
<p>Le mappe sono ancora pi√π flessibili: puoi matchare solo le chiavi che ti interessano!</p>
<pre><code class="hljs language-elixir"><span class="hljs-comment"># Estrarre valori specifici</span>
%{<span class="hljs-symbol">name:</span> nome} = %{<span class="hljs-symbol">name:</span> <span class="hljs-string">&quot;Lucia&quot;</span>, <span class="hljs-symbol">age:</span> <span class="hljs-number">23</span>, <span class="hljs-symbol">city:</span> <span class="hljs-string">&quot;Roma&quot;</span>}
<span class="hljs-comment"># nome =&gt; &quot;Lucia&quot;</span>
<span class="hljs-comment"># age e city vengono ignorati</span>

<span class="hljs-comment"># Estrarre pi√π valori</span>
%{<span class="hljs-symbol">name:</span> n, <span class="hljs-symbol">age:</span> a} = %{<span class="hljs-symbol">name:</span> <span class="hljs-string">&quot;Lucia&quot;</span>, <span class="hljs-symbol">age:</span> <span class="hljs-number">23</span>, <span class="hljs-symbol">city:</span> <span class="hljs-string">&quot;Roma&quot;</span>}
<span class="hljs-comment"># n =&gt; &quot;Lucia&quot;, a =&gt; 23</span>

<span class="hljs-comment"># Verificare che una chiave esista con un certo valore</span>
%{<span class="hljs-symbol">status:</span> <span class="hljs-symbol">:ok</span>} = %{<span class="hljs-symbol">status:</span> <span class="hljs-symbol">:ok</span>, <span class="hljs-symbol">data:</span> <span class="hljs-string">&quot;qualcosa&quot;</span>}
<span class="hljs-comment"># OK!</span>

%{<span class="hljs-symbol">status:</span> <span class="hljs-symbol">:ok</span>} = %{<span class="hljs-symbol">status:</span> <span class="hljs-symbol">:error</span>, <span class="hljs-symbol">data:</span> <span class="hljs-string">&quot;qualcosa&quot;</span>}
<span class="hljs-comment"># ** (MatchError) - status non √® :ok</span>

<span class="hljs-comment"># Combinare con atomi per validazione</span>
%{<span class="hljs-symbol">type:</span> <span class="hljs-symbol">:user</span>, <span class="hljs-symbol">id:</span> user_id} = %{<span class="hljs-symbol">type:</span> <span class="hljs-symbol">:user</span>, <span class="hljs-symbol">id:</span> <span class="hljs-number">42</span>, <span class="hljs-symbol">name:</span> <span class="hljs-string">&quot;Bob&quot;</span>}
<span class="hljs-comment"># user_id =&gt; 42</span>
<span class="hljs-comment"># Utile per validare che stiamo ricevendo il tipo giusto di dato!</span></code></pre><h3 id="pattern-matching-con-le-funzioni">Pattern Matching con le funzioni</h3>
<p>Ora guarda come sono eleganti e funzionali le definizioni di funzione:</p>
<pre><code class="hljs language-elixir"><span class="hljs-class"><span class="hljs-keyword">defmodule</span> <span class="hljs-title">FileHandler</span></span> <span class="hljs-keyword">do</span>
  <span class="hljs-comment"># Clausola 1: matcha solo se il risultato √® {:ok, contenuto}</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle</span></span>({<span class="hljs-symbol">:ok</span>, contenuto}) <span class="hljs-keyword">do</span>
    <span class="hljs-string">&quot;File letto con successo: <span class="hljs-subst">#{contenuto}</span>&quot;</span>
  <span class="hljs-keyword">end</span>
  
  <span class="hljs-comment"># Clausola 2: matcha solo se il risultato √® {:error, motivo}</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle</span></span>({<span class="hljs-symbol">:error</span>, motivo}) <span class="hljs-keyword">do</span>
    <span class="hljs-string">&quot;Errore nella lettura: <span class="hljs-subst">#{motivo}</span>&quot;</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># Uso</span>
<span class="hljs-title class_">File</span>.read(<span class="hljs-string">&quot;test.txt&quot;</span>) |&gt; <span class="hljs-title class_">FileHandler</span>.handle()
<span class="hljs-comment"># Elixir sceglie automaticamente la clausola giusta!</span></code></pre><blockquote>
<p>definire la definizione di funzione funzionale sembra quasi un gioco di parole</p>
</blockquote>
<h3 id="il-pin-operator">Il pin operator (^)</h3>
<p>A volte non vuoi riassegnare una variabile, ma vuoi matchare contro il suo valore attuale:</p>
<pre><code class="hljs language-elixir"><span class="hljs-comment"># Senza pin: riassegna</span>
x = <span class="hljs-number">1</span>
x = <span class="hljs-number">2</span>  <span class="hljs-comment"># x ora vale 2</span>

<span class="hljs-comment"># Con pin: matcha il valore attuale</span>
x = <span class="hljs-number">1</span>
^x = <span class="hljs-number">1</span>  <span class="hljs-comment"># OK, matcha perch√© x vale 1</span>
^x = <span class="hljs-number">2</span>  <span class="hljs-comment"># Errore! x vale 1, non 2</span>

<span class="hljs-comment"># Ecco un uso pratico: come validare un valore atteso</span>
expected_status = <span class="hljs-symbol">:ok</span>
^expected_status = get_status()
<span class="hljs-comment"># Si assicura che get_status() ritorni :ok, altrimenti crasha</span></code></pre><h3 id="lunderscore-il-jolly">L&#39;underscore: il jolly</h3>
<p>L&#39;underscore <code>_</code> matcha qualsiasi cosa ma non la lega a una variabile:</p>
<pre><code class="hljs language-elixir"><span class="hljs-comment"># Ignorare completamente un valore</span>
{<span class="hljs-symbol">:ok</span>, _} = {<span class="hljs-symbol">:ok</span>, <span class="hljs-string">&quot;Non mi interessa&quot;</span>}

<span class="hljs-comment"># Ignorare parti di una lista</span>
[_, secondo, _, quarto] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
<span class="hljs-comment"># secondo =&gt; 2, quarto =&gt; 4</span>

<span class="hljs-comment"># Dare un nome descrittivo ma non usare il valore (evita warning). In _ ci sar√† tutto il contenuto che non usi</span>
{<span class="hljs-symbol">:ok</span>, _} = <span class="hljs-title class_">File</span>.read(<span class="hljs-string">&quot;test.txt&quot;</span>)</code></pre><h3 id="pattern-matching-ovunque">Pattern Matching ovunque!</h3>
<p>Il pattern matching non si usa solo con <code>=</code>. √à ovunque in Elixir:</p>
<pre><code class="hljs language-elixir"><span class="hljs-comment"># Nelle funzioni (vedi sezione 6)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calcola</span></span>({<span class="hljs-symbol">:somma</span>, a, b}), <span class="hljs-symbol">do:</span> a + b
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calcola</span></span>({<span class="hljs-symbol">:prodotto</span>, a, b}), <span class="hljs-symbol">do:</span> a * b

<span class="hljs-comment"># Nel case (vedi sezione 8)</span>
<span class="hljs-keyword">case</span> <span class="hljs-title class_">File</span>.read(<span class="hljs-string">&quot;file.txt&quot;</span>) <span class="hljs-keyword">do</span>
  {<span class="hljs-symbol">:ok</span>, contenuto} -&gt; <span class="hljs-string">&quot;Letto: <span class="hljs-subst">#{contenuto}</span>&quot;</span>
  {<span class="hljs-symbol">:error</span>, <span class="hljs-symbol">:enoent</span>} -&gt; <span class="hljs-string">&quot;File non trovato&quot;</span>
  {<span class="hljs-symbol">:error</span>, motivo} -&gt; <span class="hljs-string">&quot;Errore: <span class="hljs-subst">#{motivo}</span>&quot;</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># Nelle list comprehensions</span>
<span class="hljs-keyword">for</span> {<span class="hljs-symbol">:ok</span>, valore} &lt;- results, <span class="hljs-symbol">do:</span> valore

<span class="hljs-comment"># Nei parametri di funzioni anonime</span>
<span class="hljs-title class_">Enum</span>.map([{<span class="hljs-symbol">:ok</span>, <span class="hljs-number">1</span>}, {<span class="hljs-symbol">:ok</span>, <span class="hljs-number">2</span>}], <span class="hljs-keyword">fn</span> {<span class="hljs-symbol">:ok</span>, n} -&gt; n * <span class="hljs-number">2</span> <span class="hljs-keyword">end</span>)</code></pre><blockquote>
<p>üí° <strong>Pro Tip</strong>: Il pattern matching ti permette di scrivere codice <strong>dichiarativo</strong> invece che <strong>imperativo</strong>. Invece di chiedere &quot;questo valore √® ok? Poi estrailo&quot;, dici &quot;questo deve essere {:ok, valore}&quot; e Elixir fa tutto il lavoro sporco. Se il pattern non matcha, il programma crasha (fail fast), che √® esattamente quello che vuoi durante lo sviluppo, ovvero, non avere problemi dopo, ma capire subito se c&#39;√® un problema.</p>
</blockquote>
<h2 id="6-funzioni-e-moduli">6. Funzioni e moduli</h2>
<p>Il codice vive nei <strong>moduli</strong>. Le funzioni possono essere &quot;con nome&quot; (<code>def</code>) o &quot;anonime&quot; (<code>fn</code>). Una cosa bellissima? Puoi definire la stessa funzione pi√π volte con argomenti diversi, sfruttando il <strong>pattern matching nella firma della funzione</strong> (che hai appena visto nella sezione precedente!).</p>
<h3 id="funzioni-con-nome">Funzioni con nome</h3>
<pre><code class="hljs language-elixir"><span class="hljs-class"><span class="hljs-keyword">defmodule</span> <span class="hljs-title">Math</span></span> <span class="hljs-keyword">do</span>
  <span class="hljs-comment"># Funzione semplice</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>(a, b), <span class="hljs-symbol">do:</span> a + b
  
  <span class="hljs-comment"># Funzione con corpo multi-linea</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">multiply</span></span>(a, b) <span class="hljs-keyword">do</span>
    result = a * b
    result
  <span class="hljs-keyword">end</span>
  
  <span class="hljs-comment"># Funzione privata (solo dentro il modulo)</span>
  <span class="hljs-function"><span class="hljs-keyword">defp</span> <span class="hljs-title">private_helper</span></span>(x), <span class="hljs-symbol">do:</span> x * <span class="hljs-number">2</span>
<span class="hljs-keyword">end</span>

<span class="hljs-title class_">Math</span>.add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)      <span class="hljs-comment"># =&gt; 5</span>
<span class="hljs-title class_">Math</span>.multiply(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>) <span class="hljs-comment"># =&gt; 20</span></code></pre><h3 id="pattern-matching-nelle-funzioni">Pattern Matching nelle funzioni</h3>
<p>Ora che conosci il pattern matching, ecco dove diventa davvero utile e potente, o meglio che ti permette di fare un sacco di cose:</p>
<pre><code class="hljs language-elixir"><span class="hljs-class"><span class="hljs-keyword">defmodule</span> <span class="hljs-title">FileHandler</span></span> <span class="hljs-keyword">do</span>
  <span class="hljs-comment"># Clausola 1: matcha {:ok, contenuto}</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process</span></span>({<span class="hljs-symbol">:ok</span>, contenuto}) <span class="hljs-keyword">do</span>
    <span class="hljs-string">&quot;Elaborato: <span class="hljs-subst">#{contenuto}</span>&quot;</span>
  <span class="hljs-keyword">end</span>
  
  <span class="hljs-comment"># Clausola 2: matcha {:error, motivo}</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process</span></span>({<span class="hljs-symbol">:error</span>, motivo}) <span class="hljs-keyword">do</span>
    <span class="hljs-string">&quot;Errore: <span class="hljs-subst">#{motivo}</span>&quot;</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># Elixir sceglie automaticamente la clausola giusta!</span>
<span class="hljs-title class_">FileHandler</span>.process({<span class="hljs-symbol">:ok</span>, <span class="hljs-string">&quot;dati&quot;</span>})    <span class="hljs-comment"># =&gt; &quot;Elaborato: dati&quot;</span>
<span class="hljs-title class_">FileHandler</span>.process({<span class="hljs-symbol">:error</span>, <span class="hljs-string">&quot;boom&quot;</span>}) <span class="hljs-comment"># =&gt; &quot;Errore: boom&quot;</span></code></pre><h3 id="ricorsione-con-pattern-matching">Ricorsione con Pattern Matching</h3>
<p>Il pattern matching rende la ricorsione elegantissima:</p>
<pre><code class="hljs language-elixir"><span class="hljs-class"><span class="hljs-keyword">defmodule</span> <span class="hljs-title">Math</span></span> <span class="hljs-keyword">do</span>
  <span class="hljs-comment"># Caso base: 0! = 1</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">factorial</span></span>(<span class="hljs-number">0</span>), <span class="hljs-symbol">do:</span> <span class="hljs-number">1</span>
  
  <span class="hljs-comment"># Caso ricorsivo: n! = n * (n-1)!</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">factorial</span></span>(n) <span class="hljs-keyword">when</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">do</span>
    n * factorial(n - <span class="hljs-number">1</span>)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-title class_">Math</span>.factorial(<span class="hljs-number">5</span>) <span class="hljs-comment"># =&gt; 120</span></code></pre><pre><code class="hljs language-elixir"><span class="hljs-class"><span class="hljs-keyword">defmodule</span> <span class="hljs-title">ListHelper</span></span> <span class="hljs-keyword">do</span>
  <span class="hljs-comment"># Caso base: lista vuota</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span></span>([]), <span class="hljs-symbol">do:</span> <span class="hljs-number">0</span>
  
  <span class="hljs-comment"># Caso ricorsivo: somma la testa + somma della coda</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span></span>([head | tail]) <span class="hljs-keyword">do</span>
    head + sum(tail)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-title class_">ListHelper</span>.sum([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]) <span class="hljs-comment"># =&gt; 10</span></code></pre><h3 id="guard-clauses">Guard Clauses</h3>
<p>Le guard clauses aggiungono condizioni extra <strong>dopo</strong> il pattern matching:</p>
<pre><code class="hljs language-elixir"><span class="hljs-class"><span class="hljs-keyword">defmodule</span> <span class="hljs-title">Temperature</span></span> <span class="hljs-keyword">do</span>
  <span class="hljs-comment"># Pattern matching + condizione</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(temp) <span class="hljs-keyword">when</span> temp &gt; <span class="hljs-number">30</span>, <span class="hljs-symbol">do:</span> <span class="hljs-string">&quot;Caldissimo! üî•&quot;</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(temp) <span class="hljs-keyword">when</span> temp &gt; <span class="hljs-number">15</span>, <span class="hljs-symbol">do:</span> <span class="hljs-string">&quot;Mite üòä&quot;</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(temp) <span class="hljs-keyword">when</span> temp &gt; <span class="hljs-number">0</span>, <span class="hljs-symbol">do:</span> <span class="hljs-string">&quot;Freddo ü•∂&quot;</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe</span></span>(_), <span class="hljs-symbol">do:</span> <span class="hljs-string">&quot;Gelido ‚ùÑÔ∏è&quot;</span> <span class="hljs-comment"># forma di catch‚Äëall senza warning di variabile inutilizzata. Simile ad un else.</span>
<span class="hljs-keyword">end</span>

<span class="hljs-title class_">Temperature</span>.describe(<span class="hljs-number">35</span>) <span class="hljs-comment"># =&gt; &quot;Caldissimo! üî•&quot;</span>
<span class="hljs-title class_">Temperature</span>.describe(<span class="hljs-number">18</span>) <span class="hljs-comment"># =&gt; &quot;Mite üòä&quot;</span></code></pre><p>Guards supportati: <code>&lt;</code>, <code>&gt;</code>, <code>==</code>, <code>!=</code>, <code>and</code>, <code>or</code>, <code>not</code>, <code>is_list</code>, <code>is_map</code>, <code>is_atom</code>, etc.</p>
<h3 id="funzioni-anonime">Funzioni anonime</h3>
<p>Funzioni &quot;usa e getta&quot; senza nome:</p>
<pre><code class="hljs language-elixir"><span class="hljs-comment"># Sintassi classica</span>
add = <span class="hljs-keyword">fn</span> a, b -&gt; a + b <span class="hljs-keyword">end</span>
add.(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment"># =&gt; 3 (Nota il punto per chiamare le anonime!)</span>

<span class="hljs-comment"># Con pattern matching multi-clausola</span>
handle_result = <span class="hljs-keyword">fn</span>
  {<span class="hljs-symbol">:ok</span>, result} -&gt; <span class="hljs-string">&quot;Successo: <span class="hljs-subst">#{result}</span>&quot;</span>
  {<span class="hljs-symbol">:error</span>, reason} -&gt; <span class="hljs-string">&quot;Errore: <span class="hljs-subst">#{reason}</span>&quot;</span>
  _ -&gt; <span class="hljs-string">&quot;Caso non gestito&quot;</span>
<span class="hljs-keyword">end</span>

handle_result.({<span class="hljs-symbol">:ok</span>, <span class="hljs-string">&quot;tutto ok&quot;</span>}) <span class="hljs-comment"># =&gt; &quot;Successo: tutto ok&quot;</span></code></pre><h3 id="sintassi-shorthand-con">Sintassi shorthand con &amp;</h3>
<p>Per funzioni super semplici:</p>
<pre><code class="hljs language-elixir"><span class="hljs-comment"># Versione lunga</span>
<span class="hljs-title class_">Enum</span>.map([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-keyword">fn</span> x -&gt; x * <span class="hljs-number">2</span> <span class="hljs-keyword">end</span>) <span class="hljs-comment"># =&gt; [2, 4, 6]</span>

<span class="hljs-comment"># Versione corta con &amp; (capture operator)</span>
<span class="hljs-title class_">Enum</span>.map([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], &amp;(&amp;<span class="hljs-number">1</span> * <span class="hljs-number">2</span>)) <span class="hljs-comment"># =&gt; [2, 4, 6]</span>
<span class="hljs-comment"># &amp;1 = primo argomento, &amp;2 = secondo, etc.</span>

<span class="hljs-comment"># Passare funzioni esistenti</span>
<span class="hljs-title class_">Enum</span>.map([<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>], &amp;<span class="hljs-title class_">String</span>.upcase/<span class="hljs-number">1</span>)
<span class="hljs-comment"># =&gt; [&quot;HELLO&quot;, &quot;WORLD&quot;]</span></code></pre><h3 id="argomenti-di-default">Argomenti di default</h3>
<pre><code class="hljs language-elixir"><span class="hljs-class"><span class="hljs-keyword">defmodule</span> <span class="hljs-title">Greeter</span></span> <span class="hljs-keyword">do</span>
  <span class="hljs-comment"># \\ definisce un valore di default</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span></span>(name, saluto \\ <span class="hljs-string">&quot;Ciao&quot;</span>) <span class="hljs-keyword">do</span>
    <span class="hljs-string">&quot;<span class="hljs-subst">#{saluto}</span>, <span class="hljs-subst">#{name}</span>!&quot;</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-title class_">Greeter</span>.greet(<span class="hljs-string">&quot;Lucia&quot;</span>)           <span class="hljs-comment"># =&gt; &quot;Ciao, Lucia!&quot;</span>
<span class="hljs-title class_">Greeter</span>.greet(<span class="hljs-string">&quot;Lucia&quot;</span>, <span class="hljs-string">&quot;Buongiorno&quot;</span>) <span class="hljs-comment"># =&gt; &quot;Buongiorno, Lucia!&quot;</span></code></pre><blockquote>
<p>üí° <strong>Pro Tip</strong>: L&#39;ordine conta! Elixir controlla le definizioni delle funzioni <strong>dall&#39;alto in basso</strong>. Metti sempre i casi pi√π specifici (come <code>factorial(0)</code>) prima dei casi generali, altrimenti non verranno mai eseguiti. Le guard clauses vengono valutate <strong>dopo</strong> il pattern matching base.</p>
</blockquote>
<h2 id="7-loperatore-pipe-scrivere-codice-leggibile">7. L&#39;Operatore Pipe (|&gt;): Scrivere Codice Leggibile</h2>
<p>Il pipe operator <code>|&gt;</code> √® probabilmente il simbolo pi√π amato dagli sviluppatori Elixir. Prende il risultato dell&#39;espressione a sinistra e lo passa come <strong>primo argomento</strong> alla funzione a destra.</p>
<h3 id="perch-esiste">Perch√© esiste?</h3>
<p>Se non esistesse il pipe operator, il codice sarebbe un incubo di parentesi annidate:</p>
<pre><code class="hljs language-elixir"><span class="hljs-comment"># Orribile da leggere (devi leggere da dentro verso fuori)</span>
<span class="hljs-title class_">String</span>.upcase(<span class="hljs-title class_">String</span>.trim(<span class="hljs-title class_">String</span>.reverse(<span class="hljs-string">&quot;  elixir  &quot;</span>)))

<span class="hljs-comment"># Diviso in variabili temporanee (troppo verboso)</span>
step1 = <span class="hljs-title class_">String</span>.reverse(<span class="hljs-string">&quot;  elixir  &quot;</span>)
step2 = <span class="hljs-title class_">String</span>.trim(step1)
step3 = <span class="hljs-title class_">String</span>.upcase(step2)</code></pre><p>Ed ecco la soluzione, usare pipe</p>
<pre><code class="hljs language-elixir"><span class="hljs-comment"># Leggibile come una ricetta di cucina (dall&#x27;alto in basso)</span>
<span class="hljs-string">&quot;  elixir  &quot;</span>
|&gt; <span class="hljs-title class_">String</span>.reverse()
|&gt; <span class="hljs-title class_">String</span>.trim()
|&gt; <span class="hljs-title class_">String</span>.upcase()
<span class="hljs-comment"># =&gt; &quot;RIXILE&quot;</span></code></pre><p>Leggi il codice come: &quot;Prendi la stringa, POI invertila, POI rimuovi gli spazi, POI rendila maiuscola&quot;.</p>
<h3 id="come-funziona-1">Come funziona?</h3>
<p>Il pipe passa il risultato come <strong>primo argomento</strong>:</p>
<pre><code class="hljs language-elixir"><span class="hljs-comment"># Queste due espressioni sono identiche</span>
<span class="hljs-string">&quot;hello&quot;</span> |&gt; <span class="hljs-title class_">String</span>.upcase()
<span class="hljs-title class_">String</span>.upcase(<span class="hljs-string">&quot;hello&quot;</span>)

<span class="hljs-comment"># Pipeline</span>
<span class="hljs-string">&quot;hello&quot;</span> |&gt; <span class="hljs-title class_">String</span>.upcase() |&gt; <span class="hljs-title class_">String</span>.reverse()
<span class="hljs-comment"># √à uguale a:</span>
<span class="hljs-title class_">String</span>.reverse(<span class="hljs-title class_">String</span>.upcase(<span class="hljs-string">&quot;hello&quot;</span>))</code></pre><h3 id="esempi">Esempi</h3>
<pre><code class="hljs language-elixir"><span class="hljs-comment"># Processare input utente</span>
user_input
|&gt; <span class="hljs-title class_">String</span>.downcase()
|&gt; <span class="hljs-title class_">String</span>.split(<span class="hljs-string">&quot; &quot;</span>)
|&gt; <span class="hljs-title class_">Enum</span>.map(&amp;<span class="hljs-title class_">String</span>.capitalize/<span class="hljs-number">1</span>)
|&gt; <span class="hljs-title class_">Enum</span>.join(<span class="hljs-string">&quot; &quot;</span>)
<span class="hljs-comment"># &quot;hello WORLD&quot; diventa &quot;Hello World&quot;</span>

<span class="hljs-comment"># Lavorare con numeri</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
|&gt; <span class="hljs-title class_">Enum</span>.filter(&amp;(rem(&amp;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>))
|&gt; <span class="hljs-title class_">Enum</span>.map(&amp;(&amp;<span class="hljs-number">1</span> * <span class="hljs-number">10</span>))
|&gt; <span class="hljs-title class_">Enum</span>.sum()
<span class="hljs-comment"># =&gt; 60 (perch√© 2*10 + 4*10 = 60)</span>

<span class="hljs-comment"># API chain (pattern comune nel web)</span>
conn
|&gt; assign(<span class="hljs-symbol">:user</span>, current_user)
|&gt; put_flash(<span class="hljs-symbol">:info</span>, <span class="hljs-string">&quot;Benvenuto!&quot;</span>)
|&gt; render(<span class="hljs-string">&quot;index.html&quot;</span>)</code></pre><h3 id="pipe-con-funzioni-multi-argomento">Pipe con funzioni multi-argomento</h3>
<p>Ricorda: il pipe passa il valore come <strong>primo</strong> argomento. Gli altri vanno specificati:</p>
<pre><code class="hljs language-elixir"><span class="hljs-comment"># String.split richiede (stringa, separatore)</span>
<span class="hljs-string">&quot;a,b,c&quot;</span>
|&gt; <span class="hljs-title class_">String</span>.split(<span class="hljs-string">&quot;,&quot;</span>)
<span class="hljs-comment"># √à uguale a: String.split(&quot;a,b,c&quot;, &quot;,&quot;)</span>

<span class="hljs-comment"># Con pi√π argomenti</span>
<span class="hljs-string">&quot;hello world&quot;</span>
|&gt; <span class="hljs-title class_">String</span>.split(<span class="hljs-string">&quot; &quot;</span>)
|&gt; <span class="hljs-title class_">Enum</span>.join(<span class="hljs-string">&quot;-&quot;</span>)
<span class="hljs-comment"># =&gt; &quot;hello-world&quot;</span></code></pre><h3 id="debug-con-ioinspect">Debug con <code>IO.inspect</code></h3>
<p>Il trucco numero uno per fare debugging √® unire il pin e <code>IO.inspect</code>:</p>
<pre><code class="hljs language-elixir">dati
|&gt; elabora()
|&gt; <span class="hljs-title class_">IO</span>.inspect(<span class="hljs-symbol">label:</span> <span class="hljs-string">&quot;‚úì Dopo elaborazione&quot;</span>)
|&gt; trasforma()
|&gt; <span class="hljs-title class_">IO</span>.inspect(<span class="hljs-symbol">label:</span> <span class="hljs-string">&quot;‚úì Dopo trasformazione&quot;</span>)
|&gt; valida()
|&gt; <span class="hljs-title class_">IO</span>.inspect(<span class="hljs-symbol">label:</span> <span class="hljs-string">&quot;‚úì Dopo validazione&quot;</span>)
|&gt; salva()

<span class="hljs-comment"># Output in console:</span>
<span class="hljs-comment"># ‚úì Dopo elaborazione: [1, 2, 3]</span>
<span class="hljs-comment"># ‚úì Dopo trasformazione: [2, 4, 6]</span>
<span class="hljs-comment"># ‚úì Dopo validazione: {:ok, [2, 4, 6]}</span></code></pre><blockquote>
<p>üí° <strong>Pro Tip</strong>: <code>IO.inspect/2</code> (ovvero prende 2 argomenti, si usa per distinguere overload) restituisce il valore che riceve intatto, quindi non interrompe la pipeline. √à perfetto per &quot;spiare&quot; i dati mentre fluiscono. Usa sempre il parametro <code>label:</code> per sapere quale step stai vedendo!</p>
</blockquote>
<h2 id="8-control-flow-if-case-cond">8. Control Flow: if, case, cond</h2>
<p>Anche se Elixir privilegia il pattern matching, ha comunque costrutti di controllo tradizionali.</p>
<h3 id="ifunless">if/unless</h3>
<pre><code class="hljs language-elixir"><span class="hljs-keyword">if</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">do</span>
  <span class="hljs-string">&quot;Vero&quot;</span>
<span class="hljs-keyword">else</span>
  <span class="hljs-string">&quot;Falso&quot;</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># Inline</span>
<span class="hljs-keyword">if</span> temperatura &gt; <span class="hljs-number">25</span>, <span class="hljs-symbol">do:</span> <span class="hljs-string">&quot;Caldo&quot;</span>, <span class="hljs-symbol">else:</span> <span class="hljs-string">&quot;Freddo&quot;</span>

<span class="hljs-comment"># unless (opposto di if)</span>
<span class="hljs-keyword">unless</span> errore?, <span class="hljs-symbol">do:</span> <span class="hljs-string">&quot;Tutto ok&quot;</span></code></pre><h3 id="case">case</h3>
<p>Perfetto per il pattern matching multiplo:</p>
<pre><code class="hljs language-elixir"><span class="hljs-keyword">case</span> <span class="hljs-title class_">File</span>.read(<span class="hljs-string">&quot;file.txt&quot;</span>) <span class="hljs-keyword">do</span>
  {<span class="hljs-symbol">:ok</span>, contenuto} -&gt;
    <span class="hljs-string">&quot;File letto: <span class="hljs-subst">#{contenuto}</span>&quot;</span>
  
  {<span class="hljs-symbol">:error</span>, <span class="hljs-symbol">:enoent</span>} -&gt;
    <span class="hljs-string">&quot;File non trovato&quot;</span>
  
  {<span class="hljs-symbol">:error</span>, reason} -&gt;
    <span class="hljs-string">&quot;Errore: <span class="hljs-subst">#{reason}</span>&quot;</span>
<span class="hljs-keyword">end</span></code></pre><h3 id="cond">cond</h3>
<p>Quando hai condizioni multiple da valutare (come un else-if chain):</p>
<pre><code class="hljs language-elixir"><span class="hljs-keyword">cond</span> <span class="hljs-keyword">do</span>
  temperatura &gt; <span class="hljs-number">30</span> -&gt; <span class="hljs-string">&quot;Caldissimo&quot;</span>
  temperatura &gt; <span class="hljs-number">20</span> -&gt; <span class="hljs-string">&quot;Caldo&quot;</span>
  temperatura &gt; <span class="hljs-number">10</span> -&gt; <span class="hljs-string">&quot;Mite&quot;</span>
  <span class="hljs-literal">true</span> -&gt; <span class="hljs-string">&quot;Freddo&quot;</span>  <span class="hljs-comment"># Default case</span>
<span class="hljs-keyword">end</span></code></pre><h3 id="with">with</h3>
<p>Per concatenare operazioni che possono fallire:</p>
<pre><code class="hljs language-elixir"><span class="hljs-keyword">with</span> {<span class="hljs-symbol">:ok</span>, user} &lt;- fetch_user(id),
     {<span class="hljs-symbol">:ok</span>, email} &lt;- validate_email(user.email),
     {<span class="hljs-symbol">:ok</span>, _} &lt;- send_email(email) <span class="hljs-keyword">do</span>
  {<span class="hljs-symbol">:ok</span>, <span class="hljs-string">&quot;Email inviata&quot;</span>}
<span class="hljs-keyword">else</span>
  {<span class="hljs-symbol">:error</span>, reason} -&gt; {<span class="hljs-symbol">:error</span>, reason}
<span class="hljs-keyword">end</span></code></pre><h2 id="9-concorrenza-processi-e-messaggi">9. Concorrenza: processi e messaggi</h2>
<p>Ecco che in questa sezione diamo un altro esempio in Elixir eccelle. I processi in Elixir <strong>non sono</strong> thread del sistema operativo, ma processi leggeri della BEAM. Puoi averne milioni contemporaneamente.</p>
<h3 id="creare-un-processo">Creare un processo</h3>
<pre><code class="hljs language-elixir"><span class="hljs-comment"># Spawn di un processo</span>
pid = spawn(<span class="hljs-keyword">fn</span> -&gt; 
  <span class="hljs-title class_">IO</span>.puts <span class="hljs-string">&quot;Ciao dal processo!&quot;</span>
<span class="hljs-keyword">end</span>)

<span class="hljs-comment"># Spawn e invio di messaggi</span>
pid = spawn(<span class="hljs-keyword">fn</span> -&gt;
  <span class="hljs-keyword">receive</span> <span class="hljs-keyword">do</span>
    {<span class="hljs-symbol">:ciao</span>, mittente} -&gt; 
      send(mittente, {<span class="hljs-symbol">:risposta</span>, <span class="hljs-string">&quot;Ciao anche a te!&quot;</span>})
    _ -&gt; 
      <span class="hljs-title class_">IO</span>.puts <span class="hljs-string">&quot;Messaggio non riconosciuto&quot;</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>)

<span class="hljs-comment"># Inviare un messaggio</span>
send(pid, {<span class="hljs-symbol">:ciao</span>, self()})

<span class="hljs-comment"># Ricevere la risposta</span>
<span class="hljs-keyword">receive</span> <span class="hljs-keyword">do</span>
  {<span class="hljs-symbol">:risposta</span>, msg} -&gt; <span class="hljs-title class_">IO</span>.puts msg
<span class="hljs-keyword">after</span>
  <span class="hljs-number">1000</span> -&gt; <span class="hljs-title class_">IO</span>.puts <span class="hljs-string">&quot;Timeout!&quot;</span>
<span class="hljs-keyword">end</span></code></pre><h3 id="task-processi-con-stile">Task: processi con stile</h3>
<p>I <code>Task</code> sono un&#39;astrazione di alto livello per i processi:</p>
<pre><code class="hljs language-elixir"><span class="hljs-comment"># Task asincrono</span>
task = <span class="hljs-title class_">Task</span>.async(<span class="hljs-keyword">fn</span> -&gt; 
  <span class="hljs-symbol">:timer</span>.sleep(<span class="hljs-number">1000</span>)
  <span class="hljs-string">&quot;Risultato dopo 1 secondo&quot;</span>
<span class="hljs-keyword">end</span>)

<span class="hljs-comment"># Fare altro lavoro...</span>
<span class="hljs-title class_">IO</span>.puts <span class="hljs-string">&quot;Sto lavorando...&quot;</span>

<span class="hljs-comment"># Aspettare il risultato</span>
result = <span class="hljs-title class_">Task</span>.await(task)
<span class="hljs-title class_">IO</span>.puts result</code></pre><h3 id="agent-stato-condiviso">Agent: stato condiviso</h3>
<p>Gli <code>Agent</code> gestiscono lo stato in modo concorrente:</p>
<pre><code class="hljs language-elixir"><span class="hljs-comment"># Creare un agent</span>
{<span class="hljs-symbol">:ok</span>, counter} = <span class="hljs-title class_">Agent</span>.start_link(<span class="hljs-keyword">fn</span> -&gt; <span class="hljs-number">0</span> <span class="hljs-keyword">end</span>)

<span class="hljs-comment"># Leggere lo stato</span>
<span class="hljs-title class_">Agent</span>.get(counter, <span class="hljs-keyword">fn</span> state -&gt; state <span class="hljs-keyword">end</span>) <span class="hljs-comment"># =&gt; 0</span>

<span class="hljs-comment"># Aggiornare lo stato</span>
<span class="hljs-title class_">Agent</span>.update(counter, <span class="hljs-keyword">fn</span> state -&gt; state + <span class="hljs-number">1</span> <span class="hljs-keyword">end</span>)

<span class="hljs-comment"># Leggere e aggiornare</span>
<span class="hljs-title class_">Agent</span>.get_and_update(counter, <span class="hljs-keyword">fn</span> state -&gt; 
  {state, state + <span class="hljs-number">1</span>}  <span class="hljs-comment"># {valore_da_ritornare, nuovo_stato}</span>
<span class="hljs-keyword">end</span>)</code></pre><blockquote>
<p>üí° <strong>Pro Tip</strong>: I processi Elixir sono <strong>isolati</strong>: se uno crasha, non porta gi√π gli altri. Questo √® il principio &quot;Let it crash&quot; di Erlang. Usa i <strong>Supervisor</strong> per gestire automaticamente il riavvio di processi crashati.</p>
</blockquote>
<h2 id="10-enum-e-stream-come-lavorare-con-le-collezioni">10. Enum e Stream: come lavorare con le collezioni</h2>
<p>Il modulo <code>Enum</code> √® il tuo migliore amico per manipolare liste, mappe e qualsiasi cosa numerabile.</p>
<pre><code class="hljs language-elixir"><span class="hljs-comment"># Map</span>
<span class="hljs-title class_">Enum</span>.map([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-keyword">fn</span> x -&gt; x * <span class="hljs-number">2</span> <span class="hljs-keyword">end</span>)
<span class="hljs-comment"># =&gt; [2, 4, 6]</span>

<span class="hljs-comment"># Filter</span>
<span class="hljs-title class_">Enum</span>.filter([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-keyword">fn</span> x -&gt; rem(x, <span class="hljs-number">2</span>) == <span class="hljs-number">0</span> <span class="hljs-keyword">end</span>)
<span class="hljs-comment"># =&gt; [2, 4]</span>

<span class="hljs-comment"># Reduce</span>
<span class="hljs-title class_">Enum</span>.reduce([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">0</span>, <span class="hljs-keyword">fn</span> x, acc -&gt; x + acc <span class="hljs-keyword">end</span>)
<span class="hljs-comment"># =&gt; 6</span>

<span class="hljs-comment"># Chaining</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
|&gt; <span class="hljs-title class_">Enum</span>.filter(&amp;(rem(&amp;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>))
|&gt; <span class="hljs-title class_">Enum</span>.map(&amp;(&amp;<span class="hljs-number">1</span> * <span class="hljs-number">10</span>))
<span class="hljs-comment"># =&gt; [20, 40]</span></code></pre><h3 id="stream-lazy-evaluation">Stream: lazy evaluation</h3>
<p>A differenza di <code>Enum</code>, <code>Stream</code> √® <strong>lazy</strong> (valutazione pigra):</p>
<pre><code class="hljs language-elixir"><span class="hljs-comment"># Stream non esegue subito</span>
stream = <span class="hljs-number">1</span>..<span class="hljs-number">1_000_000</span>
|&gt; <span class="hljs-title class_">Stream</span>.map(&amp;(&amp;<span class="hljs-number">1</span> * <span class="hljs-number">3</span>))
|&gt; <span class="hljs-title class_">Stream</span>.filter(&amp;(rem(&amp;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>))

<span class="hljs-comment"># Eseguito solo quando serve</span>
<span class="hljs-title class_">Enum</span>.take(stream, <span class="hljs-number">5</span>)
<span class="hljs-comment"># =&gt; [6, 12, 18, 24, 30]</span></code></pre><h2 id="conclusione">Conclusione</h2>
<p>In questo breve viaggio abbiamo coperto i concetti fondamentali di Elixir, ovvero:</p>
<ul>
<li><strong>Atomi e stringhe</strong>: le fondamenta del tipo di dati</li>
<li><strong>Collezioni</strong>: Liste, Tuple, Mappe e Keyword Lists</li>
<li><strong>Pattern Matching</strong>: la killer feature che cambia il modo di programmare</li>
<li><strong>Funzioni e moduli</strong>: come organizzare il codice</li>
<li><strong>Pipe Operator</strong>: per scrivere codice leggibile e fluido</li>
<li><strong>Control Flow</strong>: gestione del flusso con case, cond e with</li>
<li><strong>Concorrenza</strong>: processi, Task e Agent per sfruttare la potenza della BEAM</li>
<li><strong>Enum e stream</strong>: manipolazione di collezioni eager e lazy</li>
</ul>
<h3 id="perch-scegliere-elixir">Perch√© scegliere Elixir?</h3>
<p>Diciamo che ho in mente vari motivi, ma ordinando per importanza in base alla mia esperienza posso dire:</p>
<ol>
<li><strong>Scalabilit√†</strong>: Milioni di processi concorrenti senza troppi problemi.</li>
<li><strong>Affidabilit√†</strong>: &quot;Let it crash&quot; con Supervisor per sistemi fault-tolerant.</li>
<li><strong>Produttivit√†</strong>: Sintassi chiara e strumenti fantastici (Mix, IEx, ExUnit).</li>
<li><strong>Ecosistema</strong>: Phoenix per il web, Nerves per IoT, Livebook per data science.</li>
<li><strong>Community</strong>: Accogliente e in crescita costante!</li>
</ol>
<p>Se tu ne hai altri, ti invito a scrivermi per dirmi la tua!</p>
<h3 id="prossimi-passi">Prossimi passi</h3>
<p>Se vuoi approfondire:</p>
<ul>
<li><strong>OTP (Open Telecom Platform)</strong>: GenServer, Supervisor, Application</li>
<li><strong>Phoenix Framework</strong>: per costruire applicazioni web real-time</li>
<li><strong>Ecto</strong>: il database wrapper pi√π elegante che tu abbia mai visto</li>
<li><strong>LiveView</strong>: UI interattive senza scrivere JavaScript</li>
<li><strong>Macro e Metaprogramming</strong>: estendere il linguaggio stesso</li>
</ul>
<p>La curva di apprendimento pu√≤ sembrare ripida all&#39;inizio, ma una volta che il concetto di <strong>immutabilit√†</strong> e che ci si abitua al <strong>pattern matching</strong>, non vorrai pi√π tornare indietro. Fidati di me!</p>
<h3 id="risorse-utili">Risorse utili</h3>
<ul>
<li><a href="https://elixir-lang.org/docs.html">Documentazione Ufficiale</a></li>
<li><a href="https://elixirschool.com/it/">Elixir School</a> - Tutorial gratuito in italiano</li>
<li><a href="https://exercism.org/tracks/elixir">Exercism Elixir Track</a> - Esercizi pratici</li>
<li><a href="https://www.phoenixframework.org/">Phoenix Framework</a></li>
</ul>
<p>Hai domande su una sezione specifica? Vuoi che approfondiamo GenServer o Supervisor? Scrivimi su Linkedin! </p>
<p><strong>Happy Coding!</strong> üöÄ‚ú®</p>
        </div>
      </section>
    </article>
  </main>
  <footer>
    <span data-it="¬© 2026 Mirko Calcaterra. Tutti i diritti riservati."
          data-en="¬© 2026 Mirko Calcaterra. All rights reserved.">
      ¬© 2026 Mirko Calcaterra. Tutti i diritti riservati.
    </span>
  </footer>
  <script>
    const BLOG_LANG_KEY = 'blogLang';
    const BLOG_THEME_KEY = 'blogTheme';
    const CURRENT_LANG = "it";
    const OTHER_LANG = "en";
    const OTHER_LANG_LINK = "../../../blog/en/elixir-cheatsheet/index.html";
    (function() {
      const body = document.body;
      const themeToggle = document.querySelector('.theme-toggle');
      const themeThumb = document.querySelector('.theme-toggle .theme-thumb');
      const langBtn = document.querySelector('.lang-btn');
      const tocElement = document.querySelector('.post-toc');
      const tocToggle = tocElement ? tocElement.querySelector('.post-toc__toggle') : null;
      const tocToggleText = tocElement ? tocElement.querySelector('.post-toc__toggle-text') : null;
      const tocTitle = tocElement ? tocElement.querySelector('.post-toc__title') : null;
      const tocLinks = tocElement ? Array.from(tocElement.querySelectorAll('.post-toc__link')) : [];
      const headingEntries = tocLinks
        .map((link) => {
          const id = link.getAttribute('href').slice(1);
          const target = document.getElementById(id);
          return target ? { link, target } : null;
        })
        .filter(Boolean);
      const tocLabels = CURRENT_LANG === 'it'
        ? { title: 'Indice', show: 'Mostra indice', hide: 'Nascondi indice' }
        : { title: 'Table of contents', show: 'Show table of contents', hide: 'Hide table of contents' };
      const tableWrappers = Array.from(document.querySelectorAll('.table-wrapper[data-enhanced-table]'));
      const tableLabels = CURRENT_LANG === 'it'
        ? { expand: 'Apri a schermo intero', close: 'Chiudi' }
        : { expand: 'Open full view', close: 'Close' };
      const codeBlocks = Array.from(document.querySelectorAll('.post-body pre'));
      const codeCopyLabels = {
        it: { copy: 'Copia', copied: 'Copiato!' },
        en: { copy: 'Copy', copied: 'Copied!' },
      };
      let tableOverlay = null;
      let tableOverlayScroll = null;
      let tableOverlayClose = null;
      if (tocTitle) {
        tocTitle.textContent = tocLabels.title;
      }
      if (tocToggleText) {
        tocToggleText.textContent = tocLabels.title;
      }
      let tocCollapsed = false;
      let tocManualOverride = false;
      const tocMediaQuery = window.matchMedia ? window.matchMedia('(max-width: 1024px)') : null;
      function ensureTableOverlay() {
        if (tableOverlay) {
          return;
        }
        tableOverlay = document.createElement('div');
        tableOverlay.className = 'table-overlay';
        tableOverlay.innerHTML =
          '<div class="table-overlay__content">' +
          '<button type="button" class="table-overlay__close">' + tableLabels.close + '</button>' +
          '<div class="table-overlay__scroll"></div>' +
          '</div>';
        body.appendChild(tableOverlay);
        tableOverlayScroll = tableOverlay.querySelector('.table-overlay__scroll');
        tableOverlayClose = tableOverlay.querySelector('.table-overlay__close');
        if (tableOverlayClose) {
          tableOverlayClose.setAttribute('aria-label', tableLabels.close);
          tableOverlayClose.addEventListener('click', closeTableOverlay);
        }
        tableOverlay.addEventListener('click', (event) => {
          if (event.target === tableOverlay) {
            closeTableOverlay();
          }
        });
      }
      function closeTableOverlay() {
        if (!tableOverlay) {
          return;
        }
        tableOverlay.classList.remove('table-overlay--visible');
        body.classList.remove('no-scroll');
        if (tableOverlayScroll) {
          tableOverlayScroll.innerHTML = '';
        }
      }
      function openTableOverlay(wrapper) {
        ensureTableOverlay();
        if (!tableOverlay || !tableOverlayScroll) {
          return;
        }
        tableOverlayScroll.innerHTML = '';
        const table = wrapper.querySelector('table');
        if (table) {
          const clone = table.cloneNode(true);
          const tableSize = table.dataset.tableSize;
          if (tableSize) {
            clone.dataset.tableSize = tableSize;
          }
          tableOverlayScroll.appendChild(clone);
        }
        tableOverlay.classList.add('table-overlay--visible');
        body.classList.add('no-scroll');
        if (tableOverlayClose) {
          tableOverlayClose.focus();
        }
      }
      function enhanceTables() {
        if (!tableWrappers.length) {
          return;
        }
        tableWrappers.forEach((wrapper) => {
          if (wrapper.dataset.enhanced === 'true') {
            return;
          }
          const table = wrapper.querySelector('table');
          if (!table) {
            return;
          }
          const headerCells = table.querySelectorAll('thead th');
          const referenceCells = headerCells.length ? headerCells : table.querySelectorAll('tr:first-child > *');
          const columnCount = referenceCells.length;
          let tableSize = '';
          if (columnCount >= 6) {
            tableSize = 'wide';
          } else if (columnCount >= 4) {
            tableSize = 'medium';
          }
          if (tableSize) {
            wrapper.setAttribute('data-table-size', tableSize);
            table.dataset.tableSize = tableSize;
          }
          const expandBtn = document.createElement('button');
          expandBtn.type = 'button';
          expandBtn.className = 'table-wrapper__expand';
          expandBtn.innerHTML = '<span aria-hidden="true">üîç</span> ' + tableLabels.expand;
          expandBtn.setAttribute('aria-label', tableLabels.expand);
          expandBtn.addEventListener('click', () => openTableOverlay(wrapper));
          wrapper.appendChild(expandBtn);
          wrapper.dataset.enhanced = 'true';
        });
      }
      function fallbackCopy(text) {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.setAttribute('readonly', '');
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        textarea.style.left = '-9999px';
        document.body.appendChild(textarea);
        textarea.select();
        let successful = false;
        try {
          successful = document.execCommand('copy');
        } catch (error) {
          successful = false;
        }
        textarea.remove();
        return successful;
      }
      function showCopyFeedback(button, labels) {
        if (button._copyTimeout) {
          clearTimeout(button._copyTimeout);
        }
        const labelEl = button.querySelector('.code-copy-btn__text');
        button.classList.add('code-copy-btn--copied');
        if (labelEl) {
          labelEl.textContent = labels.copied;
        }
        button._copyTimeout = window.setTimeout(() => {
          button.classList.remove('code-copy-btn--copied');
          if (labelEl) {
            labelEl.textContent = labels.copy;
          }
        }, 2000);
      }
      function enhanceCodeBlocks() {
        if (!codeBlocks.length) {
          return;
        }
        const labels = codeCopyLabels[CURRENT_LANG] || codeCopyLabels.en;
        codeBlocks.forEach((pre) => {
          if (pre.dataset.copyEnhanced === 'true') {
            return;
          }
          const code = pre.querySelector('code');
          if (!code) {
            return;
          }
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'code-copy-btn';
          button.setAttribute('aria-label', labels.copy);
          button.innerHTML =
            '<span class="code-copy-btn__icon" aria-hidden="true">üìã</span>' +
            '<span class="code-copy-btn__text">' + labels.copy + '</span>';
          button.addEventListener('click', async () => {
            const text = (code.textContent || '').replace(/s+$/, '');
            if (!text) {
              return;
            }
            let copied = false;
            if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
              try {
                await navigator.clipboard.writeText(text);
                copied = true;
              } catch (error) {
                copied = false;
              }
            }
            if (!copied) {
              copied = fallbackCopy(text);
            }
            if (copied) {
              showCopyFeedback(button, labels);
            }
          });
          pre.appendChild(button);
          pre.dataset.copyEnhanced = 'true';
        });
      }
      function setTocCollapsed(collapsed, { manual = false } = {}) {
        if (!tocElement) {
          return;
        }
        tocCollapsed = Boolean(collapsed);
        if (manual) {
          tocManualOverride = true;
        }
        tocElement.classList.toggle('post-toc--collapsed', tocCollapsed);
        tocElement.setAttribute('data-collapsed', tocCollapsed ? 'true' : 'false');
        if (tocToggle) {
          tocToggle.setAttribute('aria-expanded', tocCollapsed ? 'false' : 'true');
          tocToggle.setAttribute('aria-label', tocCollapsed ? tocLabels.show : tocLabels.hide);
        }
      }
      function initToc() {
        if (!tocElement) {
          return;
        }
        if (tocToggle) {
          tocToggle.addEventListener('click', () => {
            setTocCollapsed(!tocCollapsed, { manual: true });
          });
        }
        if (tocMediaQuery) {
          const handleMediaChange = (event) => {
            if (tocManualOverride) {
              return;
            }
            setTocCollapsed(event.matches);
          };
          if (typeof tocMediaQuery.addEventListener === 'function') {
            tocMediaQuery.addEventListener('change', handleMediaChange);
          } else if (typeof tocMediaQuery.addListener === 'function') {
            tocMediaQuery.addListener(handleMediaChange);
          }
          setTocCollapsed(tocMediaQuery.matches);
        } else {
          setTocCollapsed(false);
        }
      }
      const storedTheme = (localStorage.getItem(BLOG_THEME_KEY) || '').toLowerCase();
      const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      const initialTheme = storedTheme === 'light' ? 'light' : (storedTheme === 'dark' ? 'dark' : (prefersDark ? 'dark' : 'light'));
      let activeLink = null;
      let ticking = false;
      function applyTheme(theme) {
        const resolved = theme === 'dark' ? 'dark' : 'light';
        body.setAttribute('data-theme', resolved);
        if (themeToggle) {
          themeToggle.classList.toggle('active', resolved === 'dark');
        }
        if (themeThumb) {
          themeThumb.textContent = resolved === 'dark' ? 'üåô' : '‚òÄÔ∏è';
        }
        localStorage.setItem(BLOG_THEME_KEY, resolved);
      }
      function setActive(link) {
        if (activeLink === link) {
          return;
        }
        if (activeLink) {
          activeLink.classList.remove('post-toc__link--active');
        }
        if (link) {
          link.classList.add('post-toc__link--active');
        }
        activeLink = link;
      }
      function updateActiveHeading() {
        if (!headingEntries.length) {
          return;
        }
        const scrollPosition = window.scrollY + 160;
        let current = headingEntries[0];
        for (const item of headingEntries) {
          if (item.target.offsetTop <= scrollPosition) {
            current = item;
          } else {
            break;
          }
        }
        setActive(current.link);
      }
      function onScroll() {
        if (ticking) {
          return;
        }
        ticking = true;
        window.requestAnimationFrame(() => {
          updateActiveHeading();
          ticking = false;
        });
      }
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          closeTableOverlay();
        }
      });
      enhanceTables();
      enhanceCodeBlocks();
      initToc();
      applyTheme(initialTheme);
      if (themeToggle) {
        themeToggle.addEventListener('click', () => {
          applyTheme(body.getAttribute('data-theme') === 'dark' ? 'light' : 'dark');
        });
      }
      if (langBtn) {
        langBtn.textContent = CURRENT_LANG === 'it' ? 'EN' : 'IT';
        if (OTHER_LANG_LINK) {
          langBtn.addEventListener('click', () => {
            localStorage.setItem(BLOG_LANG_KEY, OTHER_LANG);
            window.location.href = OTHER_LANG_LINK;
          });
        } else {
          langBtn.disabled = true;
          langBtn.classList.add('lang-btn--disabled');
        }
      }
      localStorage.setItem(BLOG_LANG_KEY, CURRENT_LANG);
      if (headingEntries.length) {
        headingEntries.sort((a, b) => a.target.offsetTop - b.target.offsetTop);
        updateActiveHeading();
        window.addEventListener('scroll', onScroll, { passive: true });
      }
    })();
  </script>
</body>
</html>